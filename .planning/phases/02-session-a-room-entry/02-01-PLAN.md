---
phase: 02-session-a-room-entry
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useAuth.ts
  - src/lib/room-codes.ts
  - src/lib/rooms.ts
autonomous: true

must_haves:
  truths:
    - "Session persists in localStorage across browser refresh"
    - "Anonymous auth creates real user IDs (not anon key access)"
    - "Room codes are 4 letters from non-confusing alphabet"
    - "Duplicate room codes trigger retry with new code"
    - "Reconnecting user doesn't create duplicate participant record"
  artifacts:
    - path: "src/hooks/useAuth.ts"
      provides: "Session recovery and auth state management"
      exports: ["useAuth"]
      min_lines: 35
    - path: "src/lib/room-codes.ts"
      provides: "4-letter room code generation"
      exports: ["generateRoomCode"]
      min_lines: 10
    - path: "src/lib/rooms.ts"
      provides: "Room creation and joining logic"
      exports: ["createRoom", "joinRoom"]
      min_lines: 60
  key_links:
    - from: "src/hooks/useAuth.ts"
      to: "supabase.auth"
      via: "getSession() and onAuthStateChange()"
      pattern: "supabase\\.auth\\.(getSession|onAuthStateChange)"
    - from: "src/lib/rooms.ts"
      to: "generateRoomCode"
      via: "import and call"
      pattern: "generateRoomCode\\(\\)"
    - from: "src/lib/rooms.ts"
      to: "supabase.from('participants').upsert"
      via: "upsert with onConflict"
      pattern: "upsert.*onConflict"
---

<objective>
Create authentication and room management infrastructure that enables anonymous session persistence and room creation/joining with collision-resistant 4-letter codes.

Purpose: Establishes the foundation for user identity and room participation without requiring accounts, enabling the zero-friction game experience.

Output: Auth hook with session recovery, room code generator, and create/join functions with duplicate prevention.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-session-a-room-entry/02-RESEARCH.md

# Prior work
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

# Existing code
@src/lib/supabase.ts
@src/lib/env.ts
</context>

<tasks>

<task type="auto">
  <name>Create useAuth hook with session recovery and state management</name>
  <files>src/hooks/useAuth.ts</files>
  <action>
Create useAuth hook following Pattern 1 and Pattern 2 from RESEARCH.md:

1. **Session recovery on mount:**
   - Call `supabase.auth.getSession()` to check localStorage
   - Set loading state to true initially, false after session check
   - Store session in state (Session | null)

2. **Auth state listener:**
   - Use `supabase.auth.onAuthStateChange()` to listen for token refresh, sign in/out
   - Update session state when auth events fire
   - Return cleanup function to unsubscribe

3. **Anonymous sign-in helper:**
   - Export `signInAnonymously()` function
   - Check if session already exists before calling `supabase.auth.signInAnonymously()`
   - Return existing session if present (prevents duplicate users per Pitfall 2)

4. **TypeScript:**
   - Import Session type from @supabase/supabase-js
   - Return { session, loading, signInAnonymously } from hook
   - Use proper types for all auth calls

DO NOT manually manage localStorage - Supabase client handles this automatically with persistSession: true (default). DO NOT implement manual token refresh - auto-refresh is enabled by default.

Reference RESEARCH.md Pattern 1 (Session Recovery Hook) for exact implementation.
  </action>
  <verify>
npx tsc --noEmit
grep -n "getSession\|onAuthStateChange\|signInAnonymously" src/hooks/useAuth.ts
  </verify>
  <done>
useAuth hook exports { session, loading, signInAnonymously }, uses Supabase auth methods, compiles without errors, follows research patterns for session recovery and duplicate prevention.
  </done>
</task>

<task type="auto">
  <name>Create room code generation and room management utilities</name>
  <files>src/lib/room-codes.ts, src/lib/rooms.ts</files>
  <action>
**File 1: src/lib/room-codes.ts**

Create room code generator following Pattern 4 from RESEARCH.md:

1. Import `customAlphabet` from nanoid
2. Export `generateRoomCode` using alphabet 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789' (excludes I/1, O/0, L)
3. Set length to 4 characters
4. Add JSDoc comment explaining collision probability (1M combinations, 50% at ~1K rooms)

Reference RESEARCH.md Pattern 4 (Room Code Generator) for exact implementation.

**File 2: src/lib/rooms.ts**

Create room management functions following Pattern 4 and Pattern 5 from RESEARCH.md:

1. **createRoom(userId: string, isStoryteller: boolean):**
   - Import generateRoomCode from ./room-codes
   - Generate code using generateRoomCode()
   - Insert into rooms table with { code, last_activity: new Date().toISOString() }
   - If error code is '23505' (unique constraint violation), retry recursively
   - After room created, insert participant record with { room_id, user_id, is_storyteller, role: 'storyteller' or 'player' }
   - Return { room, participant }
   - Import Database types from ./supabase
   - Use proper typing for all Supabase calls

2. **joinRoom(roomCode: string, userId: string, displayName: string, avatar: string):**
   - Query rooms table by code to get room_id
   - If room not found, throw Error('Room not found')
   - Upsert participant using onConflict: 'room_id,user_id' (prevents duplicates on reconnection per Pattern 5)
   - Upsert data: { room_id, user_id, display_name, avatar, is_storyteller: false, role: 'player', joined_at: new Date().toISOString() }
   - Set ignoreDuplicates: false to update existing record
   - Return participant
   - Use proper typing with Database['public']['Tables']['participants']['Row']

3. **getRoomByCode(code: string):**
   - Query rooms table by code
   - Return room or null

DO NOT implement retry loops manually for upserts - database constraint handles this. DO NOT check for participant existence before upsert - that's what upsert is for (prevents race conditions).

Reference RESEARCH.md Pattern 4 (Room Code Generation with Collision Retry) and Pattern 5 (Upsert Participant) for exact implementation.
  </action>
  <verify>
npx tsc --noEmit
grep -n "customAlphabet\|generateRoomCode" src/lib/room-codes.ts
grep -n "createRoom\|joinRoom\|getRoomByCode\|upsert.*onConflict" src/lib/rooms.ts
  </verify>
  <done>
room-codes.ts exports generateRoomCode using nanoid customAlphabet with 4-letter codes. rooms.ts exports createRoom (with collision retry), joinRoom (with upsert), and getRoomByCode. All functions use proper Database types and compile without errors.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit`
2. useAuth hook contains session recovery logic (getSession + onAuthStateChange)
3. room-codes.ts uses nanoid customAlphabet with non-confusing characters
4. rooms.ts createRoom handles 23505 collision errors with retry
5. rooms.ts joinRoom uses upsert with onConflict to prevent duplicates
6. All exports are properly typed with Database types
</verification>

<success_criteria>
- [ ] useAuth hook exported with { session, loading, signInAnonymously }
- [ ] Auth state persists across mock refresh (getSession works)
- [ ] generateRoomCode produces 4-letter codes from safe alphabet
- [ ] createRoom retries on code collision (23505 error)
- [ ] joinRoom uses upsert to prevent duplicate participants
- [ ] TypeScript compiles without errors
- [ ] All functions match research patterns
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-a-room-entry/02-01-SUMMARY.md` using the standard summary template.
</output>
