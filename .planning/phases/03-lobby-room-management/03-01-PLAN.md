---
phase: 03-lobby-room-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useParticipants.ts
  - src/components/ParticipantList.tsx
  - src/pages/RoomPage.tsx
autonomous: true

must_haves:
  truths:
    - "Player sees list of who has joined the room"
    - "Player list updates in real-time when someone joins"
    - "Player sees their own name and avatar in the list"
    - "Storyteller sees all participants including themselves"
    - "Player sees waiting indicator until game starts"
  artifacts:
    - path: "src/hooks/useParticipants.ts"
      provides: "Real-time participant subscription"
      exports: ["useParticipants"]
      min_lines: 50
    - path: "src/components/ParticipantList.tsx"
      provides: "Participant list UI component"
      exports: ["ParticipantList"]
      min_lines: 40
    - path: "src/pages/RoomPage.tsx"
      provides: "Integrated lobby view with participant list"
      contains: "useParticipants"
  key_links:
    - from: "src/pages/RoomPage.tsx"
      to: "src/hooks/useParticipants.ts"
      via: "useParticipants(roomId)"
      pattern: "useParticipants\\(.*roomId"
    - from: "src/hooks/useParticipants.ts"
      to: "supabase.channel"
      via: "Postgres Changes subscription"
      pattern: "channel.*postgres_changes"
    - from: "src/components/ParticipantList.tsx"
      to: "participants state"
      via: "props.participants.map"
      pattern: "participants\\.map"
---

<objective>
Create real-time lobby foundation with participant list visible to all users.

Purpose: Enable players to see who has joined and provide the UI foundation for Storyteller controls.
Output: Real-time participant list component with Postgres Changes subscription for live updates.
</objective>

<execution_context>
@C:/Users/TwynS/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/TwynS/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/workspace/storychat/.planning/PROJECT.md
@C:/workspace/storychat/.planning/ROADMAP.md
@C:/workspace/storychat/.planning/STATE.md

# Phase 2 completion - session and room entry working
@C:/workspace/storychat/.planning/phases/02-session-a-room-entry/02-01-SUMMARY.md
@C:/workspace/storychat/.planning/phases/02-session-a-room-entry/02-03-SUMMARY.md

# Existing code to integrate with
@C:/workspace/storychat/src/pages/RoomPage.tsx
@C:/workspace/storychat/src/lib/supabase.ts
@C:/workspace/storychat/supabase/migrations/001_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Create useParticipants hook with Realtime subscription</name>
  <files>src/hooks/useParticipants.ts</files>
  <action>
Create a custom hook that subscribes to participant changes using Supabase Postgres Changes.

**Implementation:**
- Export `useParticipants(roomId: string)` hook
- Use `useState` for participants array (type: `Database['public']['Tables']['participants']['Row'][]`)
- Use `useState` for loading state
- Use `useEffect` to:
  1. Fetch initial participants with `supabase.from('participants').select('*').eq('room_id', roomId).eq('is_active', true).order('sort_order')`
  2. Subscribe to Postgres Changes on participants table for INSERT, UPDATE, DELETE events
  3. Filter subscription by `room_id=eq.${roomId}`
  4. Update local state on each event (INSERT: add to array, UPDATE: replace matching id, DELETE: remove from array)
  5. Return cleanup function that unsubscribes from channel
- Return `{ participants, loading }`

**Pattern from RESEARCH.md:**
Use Postgres Changes (not Broadcast) for state synchronization. Postgres Changes guarantees consistency with database state.

**Why not Broadcast:**
Broadcast is for ephemeral events (typing indicators, presence). Participant list must match database state, so Postgres Changes is correct.

**Subscription setup:**
```typescript
supabase
  .channel(`room:${roomId}:participants`)
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'participants',
    filter: `room_id=eq.${roomId}`
  }, handleChange)
  .subscribe()
```

**Important:** Filter to `is_active = true` in initial query (kicked participants have `is_active = false`).
  </action>
  <verify>npx tsc --noEmit && grep -q "useParticipants" src/hooks/useParticipants.ts && grep -q "postgres_changes" src/hooks/useParticipants.ts</verify>
  <done>useParticipants hook exports participants array and loading state, subscribes to real-time updates via Postgres Changes</done>
</task>

<task type="auto">
  <name>Create ParticipantList component</name>
  <files>src/components/ParticipantList.tsx</files>
  <action>
Create a reusable component that displays the participant list.

**Props:**
- `participants: Database['public']['Tables']['participants']['Row'][]`
- `currentUserId: string` (to highlight current user)
- `showRole?: boolean` (default true - show Storyteller/Player badge)

**UI Structure (Mobile-first):**
- Use Mantine `Stack` for vertical list
- Each participant: `Group` with:
  - Avatar emoji (size 24px)
  - Display name (Text)
  - Role badge (if showRole=true): Storyteller=crimson filled, Player=gray light
  - Highlight current user with subtle background (use `bg` prop with `dark.6`)
- Empty state: "Waiting for players to join..." (Text, dimmed, size sm)

**Styling:**
- Gothic theme: dark background, crimson accents for Storyteller
- Use Mantine spacing system (gap="sm" for list)
- Current user indicator: slight background highlight, not bold text (accessibility)

**Sort order:**
Participants already ordered by `sort_order` from database query (no client-side sorting needed).

**Accessibility:**
- Semantic HTML: use `role="list"` and `role="listitem"`
- Each participant has aria-label: "{avatar} {name} - {role}"
  </action>
  <verify>npx tsc --noEmit && grep -q "ParticipantList" src/components/ParticipantList.tsx && grep -q "participants.map" src/components/ParticipantList.tsx</verify>
  <done>ParticipantList component renders participant array with avatars, names, roles, and highlights current user</done>
</task>

<task type="auto">
  <name>Integrate participant list into RoomPage</name>
  <files>src/pages/RoomPage.tsx</files>
  <action>
Update RoomPage to use the new participant list with role-specific views.

**Changes:**
1. Import `useParticipants` and `ParticipantList`
2. Extract `roomId` and `userId` from loader data (`participant.rooms.id`, `participant.user_id`)
3. Call `useParticipants(participant.rooms.id)` hook
4. Show loading skeleton while `loading` is true (use Mantine `Skeleton` with count=3 for 3 placeholder rows)
5. Replace placeholder text with role-specific content:

**For Storyteller (participant.role === 'storyteller'):**
- Title: "Lobby - Room {code}"
- Room code display (keep existing Code component)
- ParticipantList with all participants
- Text hint: "Manage players and start the game" (size sm, dimmed)

**For Player (participant.role === 'player'):**
- Title: "Waiting for Storyteller..."
- Room code display (keep existing Code component)
- ParticipantList with all participants
- Loader component with text: "The game will start soon" (use Mantine `Loader` with dots variant)

**Layout:**
- Use existing Container + Stack structure
- Keep mobile-first responsive design
- Remove the Phase 3 placeholder text

**Important:** The loader returns `participant.is_storyteller` which is deprecated. Use `participant.role === 'storyteller'` instead (matches database schema from 001_initial_schema.sql).

**Note:** The waiting indicator created here (Loader with "The game will start soon") will be verified in Plan 03-02 Task 3, which confirms it is replaced by game view when roomStatus changes to 'active'.
  </action>
  <verify>npx tsc --noEmit && grep -q "useParticipants" src/pages/RoomPage.tsx && grep -q "ParticipantList" src/pages/RoomPage.tsx && grep -q "role === 'storyteller'" src/pages/RoomPage.tsx</verify>
  <done>RoomPage shows real-time participant list with role-specific UI (Storyteller sees management hints, Player sees waiting state)</done>
</task>

</tasks>

<verification>
**Manual checks:**
1. Open browser to localhost, create a room as Storyteller
2. Open incognito tab, join the same room as Player
3. Verify Player appears in Storyteller's participant list within 1 second
4. Verify both tabs show the participant list with 2 people
5. Verify current user is highlighted in both views
6. Verify Storyteller sees "Manage players" hint
7. Verify Player sees "Waiting for Storyteller..." and loading indicator
8. Verify player waiting state is temporary (will be replaced in Plan 03-02 when game starts)

**Code checks:**
- TypeScript compiles without errors
- useParticipants hook subscribes to Postgres Changes
- ParticipantList renders participants.map
- RoomPage uses role-based conditional rendering
</verification>

<success_criteria>
- [ ] useParticipants hook fetches participants and subscribes to real-time updates
- [ ] ParticipantList component displays avatars, names, and roles
- [ ] RoomPage shows participant list with loading state
- [ ] Storyteller view shows management hints
- [ ] Player view shows waiting indicator
- [ ] Real-time updates: joining player appears in list within 1 second
- [ ] Current user is visually distinguished in the list
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `C:/workspace/storychat/.planning/phases/03-lobby-room-management/03-01-SUMMARY.md`
</output>
