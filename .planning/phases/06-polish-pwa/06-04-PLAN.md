---
phase: 06-polish-pwa
plan: 04
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - supabase/migrations/006_push_subscriptions.sql
  - supabase/functions/send-push/index.ts
  - src/lib/push-subscription.ts
  - src/hooks/usePushNotifications.ts
  - src/components/PushNotificationPrompt.tsx
  - src/pages/RoomPage.tsx
autonomous: false
user_setup:
  - service: vapid
    why: "Web Push requires VAPID keys for server authentication"
    env_vars:
      - name: VAPID_PUBLIC_KEY
        source: "Generate with: npx web-push generate-vapid-keys"
      - name: VAPID_PRIVATE_KEY
        source: "Generate with: npx web-push generate-vapid-keys"
    dashboard_config:
      - task: "Store VAPID keys in Supabase secrets"
        location: "supabase secrets set VAPID_PUBLIC_KEY=... VAPID_PRIVATE_KEY=..."

must_haves:
  truths:
    - "App requests notification permission when game starts"
    - "User with app backgrounded receives push notification for new message"
    - "Tapping notification opens app to relevant chat"
    - "iOS users see guidance to install PWA for push support"
  artifacts:
    - path: "supabase/migrations/006_push_subscriptions.sql"
      provides: "Push subscription storage table"
      contains: "push_subscriptions"
    - path: "supabase/functions/send-push/index.ts"
      provides: "Edge Function for push delivery"
      contains: "webpush"
    - path: "src/hooks/usePushNotifications.ts"
      provides: "Push subscription management hook"
      exports: ["usePushNotifications"]
      min_lines: 50
    - path: "src/components/PushNotificationPrompt.tsx"
      provides: "UI for requesting notification permission"
      exports: ["PushNotificationPrompt"]
      min_lines: 40
  key_links:
    - from: "src/hooks/usePushNotifications.ts"
      to: "PushManager"
      via: "navigator.serviceWorker.ready + pushManager.subscribe"
      pattern: "pushManager\\.subscribe"
    - from: "supabase/functions/send-push/index.ts"
      to: "@negrel/webpush"
      via: "ApplicationServer.new + subscriber.pushTextMessage"
      pattern: "pushTextMessage"
---

<objective>
Implement push notifications for new message alerts when app is backgrounded.

Purpose: Players and Storytellers need to know when new messages arrive, even when not actively looking at the app during in-person game night.

Output: Push subscription management, Edge Function for delivery, service worker handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-polish-pwa/06-RESEARCH.md
@.planning/phases/06-polish-pwa/06-01-SUMMARY.md

@src/lib/pwa.ts
@src/hooks/useMessages.ts
@vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create push subscription database and Edge Function</name>
  <files>supabase/migrations/006_push_subscriptions.sql, supabase/functions/send-push/index.ts</files>
  <action>
**1. Create supabase/migrations/006_push_subscriptions.sql:**

```sql
-- Push notification subscriptions
-- Stores Web Push subscriptions per participant

CREATE TABLE IF NOT EXISTS push_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  participant_id UUID NOT NULL REFERENCES participants(id) ON DELETE CASCADE,
  endpoint TEXT NOT NULL,
  p256dh TEXT NOT NULL,  -- Public key for encryption
  auth TEXT NOT NULL,     -- Authentication secret
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- One subscription per endpoint (handles re-subscription)
  UNIQUE(endpoint)
);

-- Index for efficient lookups by participant
CREATE INDEX idx_push_subscriptions_participant
  ON push_subscriptions(participant_id);

-- RLS policies
ALTER TABLE push_subscriptions ENABLE ROW LEVEL SECURITY;

-- Users can manage their own subscriptions
CREATE POLICY "Users can insert own subscriptions"
  ON push_subscriptions FOR INSERT
  WITH CHECK (
    participant_id IN (
      SELECT id FROM participants WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can view own subscriptions"
  ON push_subscriptions FOR SELECT
  USING (
    participant_id IN (
      SELECT id FROM participants WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can delete own subscriptions"
  ON push_subscriptions FOR DELETE
  USING (
    participant_id IN (
      SELECT id FROM participants WHERE user_id = auth.uid()
    )
  );

-- Service role can read all (for Edge Function)
-- Note: Edge Functions use service_role key which bypasses RLS
```

**2. Create supabase/functions/send-push/index.ts:**

```typescript
// Deno Edge Function for sending push notifications
// Uses @negrel/webpush library for VAPID signing and encryption

import { serve } from 'https://deno.land/std@0.177.0/http/server.ts'
import * as webpush from 'jsr:@negrel/webpush'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const { subscription, payload } = await req.json()

    // Validate required fields
    if (!subscription?.endpoint || !subscription?.keys?.p256dh || !subscription?.keys?.auth) {
      return new Response(
        JSON.stringify({ error: 'Invalid subscription format' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Get VAPID keys from environment
    const vapidPublicKey = Deno.env.get('VAPID_PUBLIC_KEY')
    const vapidPrivateKey = Deno.env.get('VAPID_PRIVATE_KEY')

    if (!vapidPublicKey || !vapidPrivateKey) {
      console.error('VAPID keys not configured')
      return new Response(
        JSON.stringify({ error: 'Push not configured' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Create application server with VAPID keys
    const appServer = await webpush.ApplicationServer.new({
      contactInformation: 'mailto:admin@nightwhispers.app',
      vapidKeys: {
        publicKey: vapidPublicKey,
        privateKey: vapidPrivateKey,
      },
    })

    // Subscribe to push service
    const subscriber = appServer.subscribe({
      endpoint: subscription.endpoint,
      keys: {
        p256dh: subscription.keys.p256dh,
        auth: subscription.keys.auth,
      },
    })

    // Send notification
    await subscriber.pushTextMessage(JSON.stringify(payload), {})

    return new Response(
      JSON.stringify({ success: true }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    console.error('Push error:', error)

    // Handle expired subscription (410 Gone)
    if (error.statusCode === 410) {
      return new Response(
        JSON.stringify({ success: false, expired: true }),
        { status: 410, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    return new Response(
      JSON.stringify({ error: 'Failed to send notification' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})
```

Note: This Edge Function needs to be deployed with `supabase functions deploy send-push` and VAPID keys set via `supabase secrets set`.
  </action>
  <verify>
- Migration file exists: supabase/migrations/006_push_subscriptions.sql
- Edge Function exists: supabase/functions/send-push/index.ts
- SQL creates push_subscriptions table with correct columns
- Edge Function imports webpush and handles subscription
  </verify>
  <done>
Push infrastructure created: push_subscriptions table and send-push Edge Function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create push subscription hook and utilities</name>
  <files>src/lib/push-subscription.ts, src/hooks/usePushNotifications.ts</files>
  <action>
**1. Create src/lib/push-subscription.ts:**

```typescript
import { supabase } from './supabase'

/**
 * Convert VAPID public key from base64 URL to Uint8Array.
 * Required for PushManager.subscribe().
 */
export function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4)
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/')
  const rawData = window.atob(base64)
  return Uint8Array.from([...rawData].map(char => char.charCodeAt(0)))
}

/**
 * Subscribe to push notifications.
 * Returns the subscription or null if failed.
 */
export async function subscribeToPush(
  vapidPublicKey: string
): Promise<PushSubscription | null> {
  // Check if push is supported
  if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
    console.log('Push not supported')
    return null
  }

  // Request permission
  const permission = await Notification.requestPermission()
  if (permission !== 'granted') {
    console.log('Notification permission denied')
    return null
  }

  // Get service worker registration
  const registration = await navigator.serviceWorker.ready

  // Subscribe to push
  const subscription = await registration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
  })

  return subscription
}

/**
 * Save push subscription to database.
 */
export async function savePushSubscription(
  participantId: string,
  subscription: PushSubscription
): Promise<void> {
  const subscriptionJson = subscription.toJSON()

  const { error } = await supabase
    .from('push_subscriptions')
    .upsert({
      participant_id: participantId,
      endpoint: subscriptionJson.endpoint!,
      p256dh: subscriptionJson.keys!.p256dh,
      auth: subscriptionJson.keys!.auth,
      updated_at: new Date().toISOString(),
    }, {
      onConflict: 'endpoint',
    })

  if (error) {
    throw new Error(`Failed to save subscription: ${error.message}`)
  }
}

/**
 * Remove push subscription from database.
 */
export async function removePushSubscription(
  participantId: string
): Promise<void> {
  const { error } = await supabase
    .from('push_subscriptions')
    .delete()
    .eq('participant_id', participantId)

  if (error) {
    throw new Error(`Failed to remove subscription: ${error.message}`)
  }
}

/**
 * Send push notification via Edge Function.
 */
export async function sendPushNotification(
  subscription: {
    endpoint: string
    keys: { p256dh: string; auth: string }
  },
  payload: {
    title: string
    body: string
    tag?: string
    url?: string
    roomId?: string
  }
): Promise<{ success: boolean; expired?: boolean }> {
  const { data, error } = await supabase.functions.invoke('send-push', {
    body: { subscription, payload },
  })

  if (error) {
    console.error('Failed to send push:', error)
    return { success: false }
  }

  return data
}
```

**2. Create src/hooks/usePushNotifications.ts:**

```typescript
import { useState, useEffect, useCallback } from 'react'
import { isPWAInstalled, canSubscribeToPush, getNotificationPermission } from '../lib/pwa'
import { subscribeToPush, savePushSubscription, removePushSubscription } from '../lib/push-subscription'

// VAPID public key - this is safe to expose client-side
// TODO: Move to environment variable
const VAPID_PUBLIC_KEY = import.meta.env.VITE_VAPID_PUBLIC_KEY || ''

export type PushState =
  | 'unsupported'      // Push not available (no service worker or not PWA on iOS)
  | 'prompt'           // Can request permission
  | 'subscribed'       // Subscribed to push
  | 'denied'           // User denied permission
  | 'pwa-required'     // iOS: need to install PWA first

interface UsePushNotificationsResult {
  state: PushState
  isLoading: boolean
  subscribe: () => Promise<boolean>
  unsubscribe: () => Promise<void>
  isPWA: boolean
}

/**
 * Hook for managing push notification subscription.
 *
 * Handles:
 * - Permission state detection
 * - iOS PWA requirement detection
 * - Subscription management
 * - Database persistence
 */
export function usePushNotifications(
  participantId: string | null
): UsePushNotificationsResult {
  const [state, setState] = useState<PushState>('unsupported')
  const [isLoading, setIsLoading] = useState(true)
  const isPWA = isPWAInstalled()

  // Determine initial state
  useEffect(() => {
    async function checkState() {
      setIsLoading(true)

      // Check if push is available
      if (!canSubscribeToPush()) {
        // On iOS, check if PWA installation is needed
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent)
        if (isIOS && !isPWA) {
          setState('pwa-required')
        } else {
          setState('unsupported')
        }
        setIsLoading(false)
        return
      }

      // Check notification permission
      const permission = getNotificationPermission()
      if (permission === 'denied') {
        setState('denied')
        setIsLoading(false)
        return
      }

      // Check if already subscribed
      if (permission === 'granted') {
        const registration = await navigator.serviceWorker.ready
        const subscription = await registration.pushManager.getSubscription()
        if (subscription) {
          setState('subscribed')
          setIsLoading(false)
          return
        }
      }

      setState('prompt')
      setIsLoading(false)
    }

    checkState()
  }, [isPWA])

  // Subscribe to push notifications
  const subscribe = useCallback(async (): Promise<boolean> => {
    if (!participantId || !VAPID_PUBLIC_KEY) {
      console.error('Missing participantId or VAPID key')
      return false
    }

    setIsLoading(true)

    try {
      const subscription = await subscribeToPush(VAPID_PUBLIC_KEY)
      if (!subscription) {
        // Permission was denied
        setState('denied')
        return false
      }

      // Save to database
      await savePushSubscription(participantId, subscription)
      setState('subscribed')
      return true
    } catch (error) {
      console.error('Failed to subscribe:', error)
      return false
    } finally {
      setIsLoading(false)
    }
  }, [participantId])

  // Unsubscribe from push notifications
  const unsubscribe = useCallback(async (): Promise<void> => {
    if (!participantId) return

    setIsLoading(true)

    try {
      // Unsubscribe from push service
      const registration = await navigator.serviceWorker.ready
      const subscription = await registration.pushManager.getSubscription()
      if (subscription) {
        await subscription.unsubscribe()
      }

      // Remove from database
      await removePushSubscription(participantId)
      setState('prompt')
    } catch (error) {
      console.error('Failed to unsubscribe:', error)
    } finally {
      setIsLoading(false)
    }
  }, [participantId])

  return {
    state,
    isLoading,
    subscribe,
    unsubscribe,
    isPWA,
  }
}
```
  </action>
  <verify>
- src/lib/push-subscription.ts exists with subscribeToPush, savePushSubscription exports
- src/hooks/usePushNotifications.ts exists with usePushNotifications export
- TypeScript compiles: `npm run type-check`
  </verify>
  <done>
Push subscription utilities and hook created for managing notification permissions and subscriptions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create push notification UI and integrate</name>
  <files>src/components/PushNotificationPrompt.tsx, src/pages/RoomPage.tsx, vite.config.ts</files>
  <action>
**1. Create src/components/PushNotificationPrompt.tsx:**

```typescript
import { Alert, Button, Text, Stack, Group } from '@mantine/core'
import { IconBell, IconBellOff, IconDeviceMobile } from '@tabler/icons-react'
import { usePushNotifications, PushState } from '../hooks/usePushNotifications'

interface PushNotificationPromptProps {
  participantId: string
  onDismiss?: () => void
}

/**
 * Prompt for enabling push notifications.
 *
 * Shows different UI based on:
 * - prompt: Request permission button
 * - pwa-required: iOS "Add to Home Screen" guidance
 * - subscribed: Success state
 * - denied: Cannot enable, explain how to reset
 * - unsupported: Push not available
 */
export function PushNotificationPrompt({
  participantId,
  onDismiss,
}: PushNotificationPromptProps) {
  const { state, isLoading, subscribe, isPWA } = usePushNotifications(participantId)

  const handleEnable = async () => {
    const success = await subscribe()
    if (success && onDismiss) {
      onDismiss()
    }
  }

  if (state === 'unsupported') {
    return null  // Don't show anything
  }

  if (state === 'subscribed') {
    return (
      <Alert
        icon={<IconBell size={16} />}
        color="green"
        variant="light"
        withCloseButton
        onClose={onDismiss}
      >
        Notifications enabled! You'll be notified of new messages.
      </Alert>
    )
  }

  if (state === 'denied') {
    return (
      <Alert
        icon={<IconBellOff size={16} />}
        color="red"
        variant="light"
        withCloseButton
        onClose={onDismiss}
      >
        <Text size="sm">
          Notifications are blocked. To enable, update your browser settings for this site.
        </Text>
      </Alert>
    )
  }

  if (state === 'pwa-required') {
    return (
      <Alert
        icon={<IconDeviceMobile size={16} />}
        color="blue"
        variant="light"
        withCloseButton
        onClose={onDismiss}
      >
        <Stack gap="xs">
          <Text size="sm" fw={500}>
            Install Night Whispers for notifications
          </Text>
          <Text size="xs">
            On iOS, tap the Share button, then "Add to Home Screen" to enable push notifications.
          </Text>
        </Stack>
      </Alert>
    )
  }

  // state === 'prompt'
  return (
    <Alert
      icon={<IconBell size={16} />}
      color="crimson"
      variant="light"
    >
      <Group justify="space-between" align="center">
        <Text size="sm">
          Enable notifications to know when you receive messages.
        </Text>
        <Group gap="xs">
          <Button
            size="xs"
            variant="light"
            color="gray"
            onClick={onDismiss}
          >
            Later
          </Button>
          <Button
            size="xs"
            variant="filled"
            color="crimson"
            loading={isLoading}
            onClick={handleEnable}
          >
            Enable
          </Button>
        </Group>
      </Group>
    </Alert>
  )
}
```

**2. Update vite.config.ts to add service worker push handler:**

The vite-plugin-pwa can inject custom service worker code. Update to handle push events:

Add to VitePWA config:
```typescript
VitePWA({
  // ... existing config ...
  srcDir: 'src',
  filename: 'sw.ts',  // Custom service worker (optional, for push handling)
  strategies: 'injectManifest',  // Use custom SW instead of generateSW
  injectManifest: {
    globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
  },
})
```

OR keep using generateSW and add push handler via workbox:

Actually, for simplicity, use the default workbox and handle push in a separate file that gets merged. The simplest approach is to add push event listeners after SW registration.

Alternative: Add inline handler via vite-plugin-pwa's customizations option if available, or accept that push events need a custom SW file.

For this plan, create a minimal custom service worker:

**3. Create src/sw.ts (custom service worker with push handling):**

```typescript
/// <reference lib="webworker" />
import { precacheAndRoute } from 'workbox-precaching'

declare const self: ServiceWorkerGlobalScope

// Precache static assets (injected by vite-plugin-pwa)
precacheAndRoute(self.__WB_MANIFEST)

// Push notification handler
self.addEventListener('push', (event: PushEvent) => {
  const data = event.data?.json() ?? {}

  const options: NotificationOptions = {
    body: data.body || 'New message',
    icon: '/pwa-192x192.png',
    badge: '/pwa-192x192.png',
    tag: data.tag || 'default',
    data: {
      url: data.url || '/',
      roomId: data.roomId,
    },
    vibrate: [100, 50, 100],
  }

  event.waitUntil(
    self.registration.showNotification(data.title || 'Night Whispers', options)
  )
})

// Notification click handler - open app to relevant chat
self.addEventListener('notificationclick', (event: NotificationEvent) => {
  event.notification.close()

  const url = event.notification.data?.url || '/'

  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then(windowClients => {
      // Focus existing window if open
      for (const client of windowClients) {
        if (client.url.includes(url) && 'focus' in client) {
          return client.focus()
        }
      }
      // Otherwise open new window
      return self.clients.openWindow(url)
    })
  )
})
```

**4. Update RoomPage.tsx to show push prompt on game start:**

Add PushNotificationPrompt to active game view:

```typescript
import { PushNotificationPrompt } from '../components/PushNotificationPrompt'

// In RoomPage component, add state:
const [showPushPrompt, setShowPushPrompt] = useState(true)

// In active game view, add before other content:
{showPushPrompt && (
  <PushNotificationPrompt
    participantId={participantId}
    onDismiss={() => setShowPushPrompt(false)}
  />
)}
```
  </action>
  <verify>
- PushNotificationPrompt.tsx exists and exports component
- src/sw.ts exists with push event handlers
- RoomPage imports and renders PushNotificationPrompt
- TypeScript compiles: `npm run type-check`
- Build succeeds: `npm run build`
  </verify>
  <done>
Push notification UI created, service worker handles push events, RoomPage shows notification prompt on game start.
  </done>
</task>

</tasks>

<verification>
1. Database migration creates push_subscriptions table
2. Edge Function handles send-push request
3. usePushNotifications hook manages subscription state
4. PushNotificationPrompt renders correctly for each state
5. Service worker handles push and notificationclick events
6. TypeScript compilation passes
7. Integration test (requires VAPID keys and deployment):
   - Start game, see notification prompt
   - Enable notifications
   - Background app
   - Send message from other participant
   - Receive push notification
   - Tap notification -> app opens to chat
</verification>

<success_criteria>
- PUSH-01 delivered: App requests notification permission on game start
- PUSH-02 delivered: User receives push notification when new message arrives (app backgrounded)
- PUSH-03 delivered: Notification tap opens app to relevant chat
- iOS users see PWA installation guidance
- Push subscriptions persist in database
</success_criteria>

<checkpoint type="checkpoint:human-verify" gate="blocking">
  <what-built>Push notification infrastructure (Edge Function, subscription management, service worker)</what-built>
  <how-to-verify>
1. Generate VAPID keys: `npx web-push generate-vapid-keys`
2. Set keys in Supabase: `supabase secrets set VAPID_PUBLIC_KEY=... VAPID_PRIVATE_KEY=...`
3. Add VITE_VAPID_PUBLIC_KEY to .env
4. Deploy Edge Function: `supabase functions deploy send-push`
5. Apply migration: `supabase db push`
6. Test flow:
   - Start game, see notification prompt
   - Click "Enable" button
   - Browser permission prompt appears
   - Grant permission
   - Background the app/tab
   - Send message from another device/browser
   - Verify push notification appears
   - Tap notification -> app opens to chat
  </how-to-verify>
  <resume-signal>Type "push-verified" or describe issues</resume-signal>
</checkpoint>

<output>
After completion, create `.planning/phases/06-polish-pwa/06-04-SUMMARY.md`
</output>
