---
phase: 06-polish-pwa
plan: 03
type: execute
wave: 2
depends_on: ["06-02"]
files_modified:
  - package.json
  - src/components/StorytellerDashboard.tsx
  - src/components/desktop/PlayerSidebar.tsx
  - src/components/SortablePlayerCard.tsx
  - src/lib/rooms.ts
  - supabase/migrations/005_participant_sort_order.sql
autonomous: true

must_haves:
  truths:
    - "Storyteller can drag player cards to reorder them"
    - "Player order persists in database (survives refresh)"
    - "Drag-and-drop works on both mobile and desktop"
    - "Accessibility: keyboard support for reordering"
  artifacts:
    - path: "src/components/SortablePlayerCard.tsx"
      provides: "Draggable player card with dnd-kit"
      exports: ["SortablePlayerCard"]
      min_lines: 40
    - path: "src/lib/rooms.ts"
      provides: "Updated with updateParticipantOrder function"
      contains: "updateParticipantOrder"
  key_links:
    - from: "src/components/StorytellerDashboard.tsx"
      to: "@dnd-kit/core"
      via: "DndContext provider"
      pattern: "DndContext"
    - from: "src/components/SortablePlayerCard.tsx"
      to: "@dnd-kit/sortable"
      via: "useSortable hook"
      pattern: "useSortable"
    - from: "src/lib/rooms.ts"
      to: "supabase participants table"
      via: "updateParticipantOrder updates sort_order column"
      pattern: "sort_order"
---

<objective>
Add drag-and-drop reordering for Storyteller's player cards.

Purpose: Storytellers often want to organize players by seating order, team, or priority. Drag-and-drop provides intuitive reordering.

Output: Draggable player cards with persistent order in database.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-polish-pwa/06-RESEARCH.md
@.planning/phases/06-polish-pwa/06-02-SUMMARY.md

@src/components/StorytellerDashboard.tsx
@src/lib/rooms.ts
@src/lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dnd-kit dependencies</name>
  <files>package.json</files>
  <action>
Install dnd-kit packages:

```bash
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

Per 06-RESEARCH.md:
- Use @dnd-kit/core (stable) NOT @dnd-kit/react (experimental)
- @dnd-kit/sortable provides sortable list preset
- @dnd-kit/utilities provides CSS transform helpers

Note: There are potential React 19 compatibility concerns with dnd-kit (hasn't been updated in 1+ year). Test thoroughly. If major issues arise, fall back to non-sortable UI.
  </action>
  <verify>
- package.json includes @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities
- `npm install` completes without errors
- `npm run type-check` passes (no type errors from dnd-kit)
  </verify>
  <done>
dnd-kit packages installed: @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sortable player card and update dashboard</name>
  <files>src/components/SortablePlayerCard.tsx, src/components/StorytellerDashboard.tsx</files>
  <action>
**1. Create src/components/SortablePlayerCard.tsx:**

```typescript
import { Card, Text, Group, Badge, Stack } from '@mantine/core'
import { useSortable } from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'
import type { Database } from '../lib/supabase'
import { useUnreadCount } from '../hooks/useUnreadCount'

type Participant = Database['public']['Tables']['participants']['Row']

interface SortablePlayerCardProps {
  roomId: string
  participantId: string
  player: Participant
  onClick: () => void
}

/**
 * Draggable player card for Storyteller dashboard.
 *
 * Uses dnd-kit useSortable hook for drag-and-drop support.
 * Implements DASH-05: Storyteller can drag-and-drop to reorder player cards.
 */
export function SortablePlayerCard({
  roomId,
  participantId,
  player,
  onClick,
}: SortablePlayerCardProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: player.id })

  const unreadCount = useUnreadCount(roomId, participantId, player.id)
  const isDead = player.status === 'dead'

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    cursor: isDragging ? 'grabbing' : 'grab',
    opacity: isDragging ? 0.8 : isDead ? 0.7 : 1,
    touchAction: 'none',  // Required for mobile drag
  }

  return (
    <Card
      ref={setNodeRef}
      style={style}
      {...attributes}
      {...listeners}
      shadow="sm"
      padding="lg"
      radius="md"
      withBorder
      onClick={onClick}
    >
      <Group justify="space-between" mb="xs">
        <Group gap="sm">
          {player.avatar_id && (
            <Text
              size="xl"
              style={{ filter: isDead ? 'grayscale(100%)' : 'none' }}
            >
              {player.avatar_id}
            </Text>
          )}

          <Stack gap={4}>
            <Group gap="xs">
              <Text fw={500}>{player.display_name}</Text>
              {isDead && <Text c="dimmed">ðŸ’€</Text>}
            </Group>
            <Text size="xs" c="dimmed">Player</Text>
            {player.custom_status && (
              <Badge size="xs" variant="light" color="gray">
                {player.custom_status}
              </Badge>
            )}
          </Stack>
        </Group>

        {unreadCount > 0 && (
          <Badge color="red" variant="filled" size="lg">
            {unreadCount}
          </Badge>
        )}
      </Group>
    </Card>
  )
}
```

**2. Update StorytellerDashboard.tsx for mobile view:**

Add dnd-kit context to the mobile SimpleGrid view:

```typescript
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core'
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  rectSortingStrategy,
} from '@dnd-kit/sortable'
import { SortablePlayerCard } from './SortablePlayerCard'
```

In the mobile branch:
1. Add sensors for pointer and keyboard
2. Wrap player cards in DndContext + SortableContext
3. Use rectSortingStrategy for grid layout
4. Handle onDragEnd to reorder and persist

```typescript
// Inside StorytellerDashboard component:
const sensors = useSensors(
  useSensor(PointerSensor, {
    activationConstraint: {
      distance: 8,  // Require 8px movement before drag starts (prevents accidental drags)
    },
  }),
  useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates,
  })
)

// Local state for optimistic reordering
const [playerOrder, setPlayerOrder] = useState<string[]>([])

// Initialize order from participants
useEffect(() => {
  const sortedPlayers = participants
    .filter(p => p.role !== 'storyteller')
    .sort((a, b) => a.sort_order - b.sort_order)
  setPlayerOrder(sortedPlayers.map(p => p.id))
}, [participants])

async function handleDragEnd(event: DragEndEvent) {
  const { active, over } = event
  if (!over || active.id === over.id) return

  const oldIndex = playerOrder.indexOf(active.id as string)
  const newIndex = playerOrder.indexOf(over.id as string)
  const newOrder = arrayMove(playerOrder, oldIndex, newIndex)

  // Optimistic update
  setPlayerOrder(newOrder)

  // Persist to database
  try {
    await updateParticipantOrder(newOrder)
  } catch (error) {
    // Revert on error
    setPlayerOrder(playerOrder)
    console.error('Failed to persist order:', error)
  }
}
```

Render in mobile view:
```tsx
<DndContext
  sensors={sensors}
  collisionDetection={closestCenter}
  onDragEnd={handleDragEnd}
>
  <SortableContext items={playerOrder} strategy={rectSortingStrategy}>
    <SimpleGrid cols={{ base: 1, sm: 2 }} spacing="md">
      <BroadcastCard {...} />
      {playerOrder.map(playerId => {
        const player = participants.find(p => p.id === playerId)
        if (!player) return null
        return (
          <SortablePlayerCard
            key={player.id}
            roomId={roomId}
            participantId={participantId}
            player={player}
            onClick={() => setSelectedParticipant(player)}
          />
        )
      })}
    </SimpleGrid>
  </SortableContext>
</DndContext>
```

Also update desktop PlayerSidebar with drag-and-drop (similar pattern, using verticalListSortingStrategy instead of rectSortingStrategy).
  </action>
  <verify>
- SortablePlayerCard.tsx exists and exports SortablePlayerCard
- StorytellerDashboard imports and uses DndContext
- TypeScript compiles: `npm run type-check`
- Visual test: drag a player card and see it move
  </verify>
  <done>
Sortable player cards implemented with dnd-kit for both mobile grid and desktop sidebar.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add order persistence to database</name>
  <files>src/lib/rooms.ts, supabase/migrations/005_participant_sort_order.sql</files>
  <action>
**1. Create migration (if sort_order column doesn't exist with proper default):**

Check existing schema - participants.sort_order already exists. If it doesn't have a default or needs updating:

```sql
-- supabase/migrations/005_participant_sort_order.sql
-- Ensure sort_order column is properly set up for drag-and-drop

-- Add default value if not present
ALTER TABLE participants
  ALTER COLUMN sort_order SET DEFAULT 0;

-- Add index for efficient ordering queries
CREATE INDEX IF NOT EXISTS idx_participants_room_sort_order
  ON participants(room_id, sort_order);
```

**2. Add updateParticipantOrder function to src/lib/rooms.ts:**

```typescript
/**
 * Update participant sort order after drag-and-drop reorder.
 *
 * Takes array of participant IDs in desired order and updates
 * sort_order column for each participant.
 *
 * @param orderedIds - Array of participant IDs in new order
 */
export async function updateParticipantOrder(orderedIds: string[]): Promise<void> {
  // Update each participant with their new sort_order
  const updates = orderedIds.map((id, index) =>
    supabase
      .from('participants')
      .update({ sort_order: index })
      .eq('id', id)
  )

  // Execute all updates in parallel
  const results = await Promise.all(updates)

  // Check for errors
  const errors = results.filter(r => r.error)
  if (errors.length > 0) {
    throw new Error(`Failed to update ${errors.length} participants`)
  }
}
```

Note: This uses multiple UPDATE queries for simplicity. For large games (15+ players), consider a single RPC call or transaction. For Night Whispers target (< 20 players), parallel updates are fast enough.
  </action>
  <verify>
- updateParticipantOrder function exists in src/lib/rooms.ts
- Function is exported
- Migration file created (if needed)
- Drag a card, refresh browser, verify order persists
  </verify>
  <done>
Order persistence implemented: updateParticipantOrder saves sort_order to database, order survives page refresh.
  </done>
</task>

</tasks>

<verification>
1. dnd-kit packages installed: check package.json
2. TypeScript compilation: `npm run type-check` passes
3. Functional test:
   - Start game with 3+ players
   - Storyteller drags player card to new position
   - Card moves smoothly
   - Refresh page - order persists
4. Keyboard accessibility: Tab to card, use arrow keys to move
5. Mobile test: touch drag works (may need to test on actual device)
</verification>

<success_criteria>
- DASH-05 delivered: Storyteller can drag-and-drop to reorder player cards
- Order persists in database (sort_order column)
- Works on mobile (touch) and desktop (mouse)
- Keyboard accessible (KeyboardSensor)
- No React 19 compatibility issues (or documented workaround if issues found)
</success_criteria>

<output>
After completion, create `.planning/phases/06-polish-pwa/06-03-SUMMARY.md`
</output>
