---
phase: 06-polish-pwa
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MessageList.tsx
  - src/components/PhaseHeader.tsx
  - src/components/StorytellerDashboard.tsx
  - src/components/AnimatedMessage.tsx
autonomous: true

must_haves:
  truths:
    - "New messages animate in with slide-up transition"
    - "Phase advance shows visual transition"
    - "Card selection has subtle feedback animation"
    - "Animations respect prefers-reduced-motion"
  artifacts:
    - path: "src/components/AnimatedMessage.tsx"
      provides: "Animated message wrapper with Mantine Transition"
      exports: ["AnimatedMessage"]
      min_lines: 25
    - path: "src/components/MessageList.tsx"
      provides: "Updated to use AnimatedMessage"
      contains: "AnimatedMessage"
    - path: "src/components/PhaseHeader.tsx"
      provides: "Phase change animation"
      contains: "Transition"
  key_links:
    - from: "src/components/AnimatedMessage.tsx"
      to: "@mantine/core"
      via: "Transition component"
      pattern: "Transition"
    - from: "src/components/MessageList.tsx"
      to: "src/components/AnimatedMessage.tsx"
      via: "AnimatedMessage wrapper"
      pattern: "AnimatedMessage"
---

<objective>
Add smooth animations for key UI interactions.

Purpose: Subtle animations improve perceived quality and provide feedback for user actions. Phase changes, new messages, and card interactions should feel responsive.

Output: Animated message arrivals, phase transitions, and card interactions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-polish-pwa/06-RESEARCH.md

@src/components/MessageList.tsx
@src/components/PhaseHeader.tsx
@src/components/StorytellerDashboard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create animated message component</name>
  <files>src/components/AnimatedMessage.tsx</files>
  <action>
Create src/components/AnimatedMessage.tsx using Mantine Transition:

```typescript
import { Transition } from '@mantine/core'
import type { ReactNode } from 'react'

interface AnimatedMessageProps {
  children: ReactNode
  index: number
  isNew?: boolean
}

/**
 * Animated wrapper for message bubbles.
 *
 * New messages slide up with stagger effect.
 * Uses Mantine Transition for simple enter animations.
 *
 * Implements UX-05: Smooth animations for new messages.
 */
export function AnimatedMessage({
  children,
  index,
  isNew = false,
}: AnimatedMessageProps) {
  // Only animate new messages (not initial load)
  if (!isNew) {
    return <>{children}</>
  }

  return (
    <Transition
      mounted={true}
      transition="slide-up"
      duration={200}
      timingFunction="ease-out"
      enterDelay={Math.min(index * 30, 150)}  // Stagger with max delay
    >
      {(styles) => (
        <div style={styles}>
          {children}
        </div>
      )}
    </Transition>
  )
}
```

Notes:
- Mantine Transition handles CSS transition automatically
- slide-up is a built-in transition preset
- Stagger effect via enterDelay (capped to prevent long waits)
- isNew flag prevents animating existing messages on load
  </action>
  <verify>
- File exists: src/components/AnimatedMessage.tsx
- Exports AnimatedMessage
- TypeScript compiles: `npm run type-check`
  </verify>
  <done>
AnimatedMessage component created with slide-up transition for new messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate animations into MessageList</name>
  <files>src/components/MessageList.tsx</files>
  <action>
Update MessageList.tsx to use AnimatedMessage for new messages:

1. Import AnimatedMessage
2. Track which messages are "new" (arrived after initial load)
3. Wrap message bubbles in AnimatedMessage

Implementation approach:

```typescript
import { AnimatedMessage } from './AnimatedMessage'

// In MessageList component:
// Track initial message count to determine new messages
const [initialCount, setInitialCount] = useState<number | null>(null)

useEffect(() => {
  if (!loading && initialCount === null) {
    setInitialCount(messages.length)
  }
}, [loading, messages.length, initialCount])

// In render:
{messages.map((message, index) => {
  const isNew = initialCount !== null && index >= initialCount
  return (
    <AnimatedMessage key={message.id} index={index - (initialCount ?? 0)} isNew={isNew}>
      {/* existing message bubble */}
    </AnimatedMessage>
  )
})}
```

Alternative simpler approach - animate only the last N messages when they change:

```typescript
const [prevLength, setPrevLength] = useState(0)
const newMessageCount = messages.length - prevLength

useEffect(() => {
  // Update prev length after render to allow animation
  const timer = setTimeout(() => {
    setPrevLength(messages.length)
  }, 300)  // After animation completes
  return () => clearTimeout(timer)
}, [messages.length])

// Message is new if it's in the last newMessageCount messages
const isNew = (index: number) => index >= messages.length - newMessageCount
```

Keep it simple - the key is that newly added messages animate in, older ones don't.

Also check for prefers-reduced-motion:
```typescript
const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches

// Skip animation if reduced motion preferred
if (prefersReducedMotion) {
  return <>{children}</>
}
```
  </action>
  <verify>
- MessageList imports AnimatedMessage
- New messages animate in when sent/received
- Existing messages don't re-animate on scroll
- TypeScript compiles: `npm run type-check`
  </verify>
  <done>
MessageList updated to animate new messages with slide-up effect.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add phase transition and card animations</name>
  <files>src/components/PhaseHeader.tsx, src/components/StorytellerDashboard.tsx</files>
  <action>
**1. Update PhaseHeader.tsx with phase change animation:**

```typescript
import { Transition, Paper, Text, Group, Skeleton } from '@mantine/core'
import { useState, useEffect, useRef } from 'react'

// In PhaseHeader component:
const [animationKey, setAnimationKey] = useState(0)
const prevPhase = useRef(phase)

// Trigger animation when phase changes
useEffect(() => {
  if (phase && phase !== prevPhase.current) {
    setAnimationKey(k => k + 1)
    prevPhase.current = phase
  }
}, [phase])

// Wrap phase display in Transition:
<Transition
  key={animationKey}
  mounted={!loading && !!phase}
  transition="fade"
  duration={300}
  timingFunction="ease-out"
>
  {(styles) => (
    <Paper
      p="md"
      radius="md"
      style={{
        ...styles,
        backgroundColor: 'var(--mantine-color-dark-7)',
        borderBottom: '1px solid var(--mantine-color-dark-4)',
      }}
    >
      <Group justify="center" gap="sm">
        <Text size="xl">{phaseIcon}</Text>
        <Text size="lg" fw={700} c="crimson">
          {phase}
        </Text>
      </Group>
    </Paper>
  )}
</Transition>
```

**2. Add hover/active states to player cards in StorytellerDashboard:**

For the mobile card view, add hover and tap feedback:

```typescript
// In PlayerCard or BroadcastCard:
<Card
  shadow="sm"
  padding="lg"
  radius="md"
  withBorder
  style={{
    cursor: 'pointer',
    transition: 'transform 0.15s ease, box-shadow 0.15s ease',
  }}
  styles={{
    root: {
      '&:hover': {
        transform: 'translateY(-2px)',
        boxShadow: 'var(--mantine-shadow-md)',
      },
      '&:active': {
        transform: 'translateY(0)',
      },
    },
  }}
  onClick={onClick}
>
```

Note: Mantine Card may not support styles prop for pseudo-classes directly. Alternative approach using CSS-in-JS or className:

```tsx
// Add to Card:
className={styles.hoverCard}

// CSS module or inline style:
.hoverCard {
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}
.hoverCard:hover {
  transform: translateY(-2px);
  box-shadow: var(--mantine-shadow-md);
}
.hoverCard:active {
  transform: translateY(0);
}
```

OR use Mantine's style prop for base styles and rely on browser hover:

```tsx
style={{
  cursor: 'pointer',
  transition: 'all 0.15s ease',
}}
onMouseEnter={(e) => {
  e.currentTarget.style.transform = 'translateY(-2px)'
}}
onMouseLeave={(e) => {
  e.currentTarget.style.transform = 'translateY(0)'
}}
```

Actually, simplest approach is CSS class. Create a small CSS file or use Mantine's createStyles:

**src/components/StorytellerDashboard.module.css:**
```css
.hoverCard {
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.hoverCard:hover {
  transform: translateY(-2px);
  box-shadow: var(--mantine-shadow-md);
}

.hoverCard:active {
  transform: translateY(0);
}

@media (prefers-reduced-motion: reduce) {
  .hoverCard {
    transition: none;
  }
  .hoverCard:hover {
    transform: none;
  }
}
```

Import and use in PlayerCard/BroadcastCard components.
  </action>
  <verify>
- PhaseHeader animates on phase change
- Player cards have hover lift effect
- Animations respect prefers-reduced-motion
- TypeScript compiles: `npm run type-check`
- Visual test: hover cards, change phase, see animations
  </verify>
  <done>
Phase transition animation added, card hover effects implemented with reduced-motion support.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npm run type-check` passes
2. Animation tests:
   - Send a message -> new message slides up
   - Advance phase -> phase header transitions
   - Hover player card -> card lifts slightly
   - Click card -> card presses down briefly
3. Reduced motion test:
   - Enable "Reduce motion" in OS settings
   - Verify animations are disabled
4. Performance: animations run at 60fps (no jank)
</verification>

<success_criteria>
- UX-05 delivered: Smooth animations for card expand, new messages, phase advance
- New messages animate in with slide-up
- Phase changes have fade/scale transition
- Cards have hover lift and active press feedback
- Animations respect prefers-reduced-motion
- No performance issues on mobile
</success_criteria>

<output>
After completion, create `.planning/phases/06-polish-pwa/06-05-SUMMARY.md`
</output>
