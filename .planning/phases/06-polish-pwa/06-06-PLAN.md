---
phase: 06-polish-pwa
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/functions/send-push/index.ts
  - src/lib/push-subscription.ts
  - src/lib/message-helpers.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User with app backgrounded receives push notification when Storyteller sends message"
    - "User with app backgrounded receives push notification when player sends message"
    - "Broadcast messages trigger push notifications to all subscribed players except sender"
  artifacts:
    - path: "supabase/functions/send-push/index.ts"
      provides: "Server-side subscription lookup and push delivery"
      contains: "recipientId"
    - path: "src/lib/push-subscription.ts"
      provides: "Client wrapper for server-side push delivery"
      exports: ["sendPushToRecipient", "sendPushToRoom"]
    - path: "src/lib/message-helpers.ts"
      provides: "Push notification sending after message insert"
      contains: "sendPushToRecipient"
  key_links:
    - from: "src/lib/message-helpers.ts"
      to: "sendPushToRecipient"
      via: "function call after successful message insert"
      pattern: "sendPushToRecipient"
    - from: "src/lib/push-subscription.ts"
      to: "supabase/functions/send-push"
      via: "Edge Function invocation"
      pattern: "supabase.functions.invoke"
    - from: "supabase/functions/send-push/index.ts"
      to: "push_subscriptions table"
      via: "server-side query with service_role"
      pattern: "from.*push_subscriptions"
---

<objective>
Wire push notification sending into the message flow using server-side subscription lookup.

Purpose: VERIFICATION.md found that sendPushNotification exists but is never called. The original plan attempted client-side subscription lookup, but RLS policies only allow users to see their OWN subscriptions (a Storyteller cannot query a Player's subscription from the client). This revised plan moves subscription lookup to the Edge Function where service_role bypasses RLS.

Output: Modified send-push Edge Function that accepts recipientId/roomId, queries subscriptions server-side, and sends notifications. Client code becomes a thin wrapper.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-polish-pwa/06-VERIFICATION.md

# Key files for this gap closure
@src/lib/message-helpers.ts
@src/lib/push-subscription.ts
@supabase/functions/send-push/index.ts
@supabase/migrations/20260120063521_push_subscriptions.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance Edge Function for server-side subscription lookup</name>
  <files>supabase/functions/send-push/index.ts</files>
  <action>
Modify the send-push Edge Function to support two modes:

1. **Direct mode** (existing): Pass `subscription` object directly
2. **Lookup mode** (new): Pass `recipientId` OR `roomId` + optional `excludeSenderId`

The Edge Function uses service_role key which bypasses RLS, allowing it to query any participant's subscription.

Replace the entire Edge Function with:

```typescript
// Deno Edge Function for sending push notifications
// Uses @negrel/webpush library for VAPID signing and encryption
// Supports server-side subscription lookup (bypasses RLS)

import { serve } from 'https://deno.land/std@0.177.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import * as webpush from 'jsr:@negrel/webpush'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers':
    'authorization, x-client-info, apikey, content-type',
}

interface PushSubscription {
  endpoint: string
  keys: { p256dh: string; auth: string }
}

interface PushPayload {
  title: string
  body: string
  tag?: string
  url?: string
  roomId?: string
}

interface RequestBody {
  // Direct mode: pass subscription directly
  subscription?: PushSubscription
  // Lookup mode: pass recipientId for 1-to-1
  recipientId?: string
  // Lookup mode: pass roomId for broadcast (sends to all in room)
  roomId?: string
  // Exclude sender from broadcast notifications
  excludeSenderId?: string
  // Notification payload
  payload: PushPayload
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const body: RequestBody = await req.json()
    const { subscription, recipientId, roomId, excludeSenderId, payload } = body

    // Validate payload
    if (!payload?.title || !payload?.body) {
      return new Response(
        JSON.stringify({ error: 'Payload must include title and body' }),
        {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        }
      )
    }

    // Get VAPID keys from environment
    const vapidPublicKey = Deno.env.get('VAPID_PUBLIC_KEY')
    const vapidPrivateKey = Deno.env.get('VAPID_PRIVATE_KEY')

    if (!vapidPublicKey || !vapidPrivateKey) {
      console.error('VAPID keys not configured')
      return new Response(JSON.stringify({ error: 'Push not configured' }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      })
    }

    // Determine subscriptions to send to
    let subscriptions: PushSubscription[] = []

    if (subscription) {
      // Direct mode: use provided subscription
      if (!subscription.endpoint || !subscription.keys?.p256dh || !subscription.keys?.auth) {
        return new Response(
          JSON.stringify({ error: 'Invalid subscription format' }),
          {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          }
        )
      }
      subscriptions = [subscription]
    } else if (recipientId || roomId) {
      // Lookup mode: query subscriptions from database
      // Create Supabase client with service_role key (bypasses RLS)
      const supabaseUrl = Deno.env.get('SUPABASE_URL')!
      const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
      const supabase = createClient(supabaseUrl, supabaseServiceKey)

      if (recipientId) {
        // 1-to-1 message: get subscription for specific recipient
        const { data, error } = await supabase
          .from('push_subscriptions')
          .select('endpoint, p256dh, auth')
          .eq('participant_id', recipientId)
          .single()

        if (error) {
          // No subscription found - not an error, recipient just hasn't subscribed
          if (error.code === 'PGRST116') {
            return new Response(
              JSON.stringify({ success: true, sent: 0, reason: 'no_subscription' }),
              {
                headers: { ...corsHeaders, 'Content-Type': 'application/json' },
              }
            )
          }
          throw error
        }

        subscriptions = [{
          endpoint: data.endpoint,
          keys: { p256dh: data.p256dh, auth: data.auth },
        }]
      } else if (roomId) {
        // Broadcast: get all subscriptions for active participants in room
        const { data, error } = await supabase
          .from('push_subscriptions')
          .select(`
            participant_id,
            endpoint,
            p256dh,
            auth,
            participants!inner(room_id, is_active)
          `)
          .eq('participants.room_id', roomId)
          .eq('participants.is_active', true)

        if (error) {
          throw error
        }

        // Filter out sender and map to subscription format
        subscriptions = (data || [])
          .filter(sub => !excludeSenderId || sub.participant_id !== excludeSenderId)
          .map(sub => ({
            endpoint: sub.endpoint,
            keys: { p256dh: sub.p256dh, auth: sub.auth },
          }))

        if (subscriptions.length === 0) {
          return new Response(
            JSON.stringify({ success: true, sent: 0, reason: 'no_subscriptions' }),
            {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            }
          )
        }
      }
    } else {
      return new Response(
        JSON.stringify({ error: 'Must provide subscription, recipientId, or roomId' }),
        {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        }
      )
    }

    // Create application server with VAPID keys
    const appServer = await webpush.ApplicationServer.new({
      contactInformation: 'mailto:admin@nightwhispers.app',
      vapidKeys: {
        publicKey: vapidPublicKey,
        privateKey: vapidPrivateKey,
      },
    })

    // Send to all subscriptions
    const results = await Promise.allSettled(
      subscriptions.map(async (sub) => {
        const subscriber = appServer.subscribe({
          endpoint: sub.endpoint,
          keys: sub.keys,
        })
        await subscriber.pushTextMessage(JSON.stringify(payload), {})
        return { endpoint: sub.endpoint, success: true }
      })
    )

    // Count successes and failures
    const sent = results.filter(r => r.status === 'fulfilled').length
    const failed = results.filter(r => r.status === 'rejected').length
    const expired = results.filter(
      r => r.status === 'rejected' && (r.reason as { statusCode?: number })?.statusCode === 410
    ).length

    return new Response(
      JSON.stringify({ success: true, sent, failed, expired }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    )
  } catch (error) {
    console.error('Push error:', error)

    // Handle expired subscription (410 Gone) for direct mode
    if ((error as { statusCode?: number }).statusCode === 410) {
      return new Response(
        JSON.stringify({ success: false, expired: true }),
        {
          status: 410,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        }
      )
    }

    return new Response(
      JSON.stringify({ error: 'Failed to send notification' }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    )
  }
})
```

Key changes from original:
1. Added Supabase client creation with service_role key
2. Added recipientId lookup mode (queries single participant's subscription)
3. Added roomId broadcast mode (queries all active participants, excludes sender)
4. Returns count of sent/failed/expired for monitoring
5. Handles "no subscription" case gracefully (not an error)
  </action>
  <verify>
Deploy and test Edge Function:
```bash
npx supabase functions deploy send-push --no-verify-jwt
```
Check logs for successful deployment.
  </verify>
  <done>
Edge Function accepts recipientId or roomId parameters and queries push_subscriptions server-side using service_role key (bypasses RLS).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add client-side push delivery wrappers</name>
  <files>src/lib/push-subscription.ts</files>
  <action>
Add two new functions that wrap the Edge Function for the lookup modes. Keep the existing `sendPushNotification` for backward compatibility but add new cleaner APIs.

Add after the existing `sendPushNotification` function:

```typescript
/**
 * Send push notification to a specific recipient.
 * Subscription lookup happens server-side (bypasses RLS).
 *
 * @param recipientId - Participant ID to send notification to
 * @param payload - Notification content
 * @returns Result with sent count (0 if recipient not subscribed)
 */
export async function sendPushToRecipient(
  recipientId: string,
  payload: {
    title: string
    body: string
    tag?: string
    url?: string
    roomId?: string
  }
): Promise<{ success: boolean; sent: number; reason?: string }> {
  const { data, error } = await supabase.functions.invoke('send-push', {
    body: { recipientId, payload },
  })

  if (error) {
    console.error('Failed to send push to recipient:', error)
    return { success: false, sent: 0 }
  }

  return data
}

/**
 * Send push notification to all subscribed participants in a room.
 * Subscription lookup happens server-side (bypasses RLS).
 * Automatically excludes the sender from receiving their own notification.
 *
 * @param roomId - Room to broadcast to
 * @param excludeSenderId - Participant ID to exclude (the sender)
 * @param payload - Notification content
 * @returns Result with sent/failed counts
 */
export async function sendPushToRoom(
  roomId: string,
  excludeSenderId: string,
  payload: {
    title: string
    body: string
    tag?: string
    url?: string
    roomId?: string
  }
): Promise<{ success: boolean; sent: number; failed?: number }> {
  const { data, error } = await supabase.functions.invoke('send-push', {
    body: { roomId, excludeSenderId, payload },
  })

  if (error) {
    console.error('Failed to send push to room:', error)
    return { success: false, sent: 0 }
  }

  return data
}
```

These functions:
- Do NOT query push_subscriptions from client (would be blocked by RLS)
- Pass IDs to Edge Function which does server-side lookup
- Return structured results for monitoring/logging
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
Two new exported functions exist: sendPushToRecipient (for 1-to-1) and sendPushToRoom (for broadcast). Neither queries push_subscriptions from client.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire push sending into message flow</name>
  <files>src/lib/message-helpers.ts</files>
  <action>
Import the new push functions and integrate into sendMessage.

1. Add import at top of file:
```typescript
import { sendPushToRecipient, sendPushToRoom } from './push-subscription'
```

2. After the Broadcast send (after line ~68), add push notification logic before the return:

```typescript
  // 3. Send push notification to recipient(s)
  // Fire-and-forget - don't block message return on push delivery
  const truncatedContent = content.length > 100
    ? content.substring(0, 97) + '...'
    : content

  if (recipientId) {
    // 1-to-1 message: send to specific recipient
    sendPushToRecipient(recipientId, {
      title: 'New Message',
      body: truncatedContent,
      tag: `message-${roomId}-${recipientId}`,
      url: `/room/${roomId}`,
      roomId,
    }).catch(err => {
      console.error('Failed to send push notification:', err)
    })
  } else {
    // Broadcast message: send to all subscribed participants except sender
    sendPushToRoom(roomId, senderId, {
      title: 'Broadcast',
      body: truncatedContent,
      tag: `broadcast-${roomId}`,
      url: `/room/${roomId}`,
      roomId,
    }).catch(err => {
      console.error('Failed to send broadcast push:', err)
    })
  }

  return message
```

Key design decisions:
- Fire-and-forget pattern: Push is async, don't block message return
- Server-side subscription lookup: No RLS issues
- Sender excluded from broadcasts: excludeSenderId parameter
- Content truncation: Push body limited to 100 chars for readability
- Tag for deduplication: Same tag replaces previous notification
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Build passes: `npm run build`
3. Verify wiring: `grep -n "sendPushTo" src/lib/message-helpers.ts` shows imports and usage
  </verify>
  <done>
sendMessage function calls sendPushToRecipient for 1-to-1 messages and sendPushToRoom for broadcasts. All subscription lookups happen server-side.
  </done>
</task>

</tasks>

<verification>
## Code Verification

1. **Edge Function deployed:** `npx supabase functions list` shows send-push
2. **Import exists:** `grep "sendPushTo" src/lib/message-helpers.ts` shows imports
3. **Function called:** `grep -A5 "sendPushToRecipient\|sendPushToRoom" src/lib/message-helpers.ts` shows calls
4. **Build passes:** `npm run build` completes without errors
5. **No client-side subscription queries:** `grep -n "push_subscriptions" src/lib/push-subscription.ts` shows NO queries (only in Edge Function)

## RLS Verification

The approach is correct because:
- Client never queries push_subscriptions for OTHER users
- Client can still query own subscription (for subscribe/unsubscribe UI)
- Edge Function uses service_role key which bypasses RLS
- Sender exclusion happens server-side using excludeSenderId parameter

## Functional Verification (requires running app)

1. Open app in two browsers (Storyteller + Player)
2. Player enables push notifications
3. Put Player's browser tab in background
4. Storyteller sends 1-to-1 message to Player
5. Player should receive push notification
6. Storyteller sends broadcast message
7. All subscribed players (except Storyteller) should receive push notification

## Gap Closure Verification

The gap identified in VERIFICATION.md:
- **Before:** sendPushNotification exported but never called
- **After:** sendPushToRecipient/sendPushToRoom called in sendMessage, with server-side subscription lookup
</verification>

<success_criteria>
1. Edge Function accepts recipientId or roomId and queries subscriptions server-side
2. sendPushToRecipient and sendPushToRoom exist in src/lib/push-subscription.ts
3. No client-side queries to push_subscriptions table (except for user's own subscription management)
4. sendMessage calls sendPushToRecipient for 1-to-1 and sendPushToRoom for broadcasts
5. Sender is excluded from broadcast notifications via excludeSenderId
6. npm run build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-polish-pwa/06-06-SUMMARY.md`
</output>
