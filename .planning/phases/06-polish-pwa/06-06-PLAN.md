---
phase: 06-polish-pwa
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/message-helpers.ts
  - src/lib/push-subscription.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User with app backgrounded receives push notification when Storyteller sends message"
    - "User with app backgrounded receives push notification when player sends message"
    - "Broadcast messages trigger push notifications to all subscribed players"
  artifacts:
    - path: "src/lib/message-helpers.ts"
      provides: "Push notification sending after message insert"
      contains: "sendPushNotification"
    - path: "src/lib/push-subscription.ts"
      provides: "Function to get recipient's push subscription"
      exports: ["getRecipientPushSubscription"]
  key_links:
    - from: "src/lib/message-helpers.ts"
      to: "sendPushNotification"
      via: "function call after successful message insert"
      pattern: "sendPushNotification"
    - from: "src/lib/message-helpers.ts"
      to: "getRecipientPushSubscription"
      via: "query before sending push"
      pattern: "getRecipientPushSubscription"
---

<objective>
Wire push notification sending into the message flow so users receive notifications when messages arrive.

Purpose: VERIFICATION.md found that sendPushNotification exists but is never called - users can subscribe to push notifications but never receive them because no code triggers push delivery when messages are sent.

Output: Modified message-helpers.ts that sends push notifications after successful message insert.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-polish-pwa/06-VERIFICATION.md

# Key files for this gap closure
@src/lib/message-helpers.ts
@src/lib/push-subscription.ts
@supabase/migrations/20260120063521_push_subscriptions.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add recipient push subscription lookup</name>
  <files>src/lib/push-subscription.ts</files>
  <action>
Add a function to query the push subscription for a given participant ID:

```typescript
/**
 * Get push subscription for a participant.
 * Returns null if no subscription exists.
 */
export async function getRecipientPushSubscription(
  participantId: string
): Promise<{ endpoint: string; keys: { p256dh: string; auth: string } } | null> {
  const { data, error } = await supabase
    .from('push_subscriptions')
    .select('endpoint, p256dh, auth')
    .eq('participant_id', participantId)
    .single()

  if (error || !data) {
    return null
  }

  return {
    endpoint: data.endpoint,
    keys: {
      p256dh: data.p256dh,
      auth: data.auth,
    },
  }
}
```

Also add a function to get all subscriptions for a room (for broadcast messages):

```typescript
/**
 * Get all push subscriptions for active participants in a room.
 * Used for broadcast messages.
 */
export async function getRoomPushSubscriptions(
  roomId: string,
  excludeParticipantId?: string
): Promise<Array<{ endpoint: string; keys: { p256dh: string; auth: string } }>> {
  let query = supabase
    .from('push_subscriptions')
    .select('endpoint, p256dh, auth, participants!inner(room_id, is_active)')
    .eq('participants.room_id', roomId)
    .eq('participants.is_active', true)

  const { data, error } = await query

  if (error || !data) {
    return []
  }

  // Filter out the sender if provided
  return data
    .filter(sub => !excludeParticipantId || sub.participant_id !== excludeParticipantId)
    .map(sub => ({
      endpoint: sub.endpoint,
      keys: {
        p256dh: sub.p256dh,
        auth: sub.auth,
      },
    }))
}
```

Note: The join query `participants!inner(room_id, is_active)` filters to active participants in the room. This requires updating the select to include participant_id for filtering.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
Two new exported functions exist in push-subscription.ts: getRecipientPushSubscription and getRoomPushSubscriptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire push sending into message flow</name>
  <files>src/lib/message-helpers.ts</files>
  <action>
Import the push functions and integrate into sendMessage:

1. Import at top of file:
```typescript
import {
  sendPushNotification,
  getRecipientPushSubscription,
  getRoomPushSubscriptions,
} from './push-subscription'
```

2. After successful database insert and broadcast (after line ~68), add push notification logic:

```typescript
// 3. Send push notification to recipient(s)
// Fire-and-forget - don't block message return on push delivery
// Only send if we have a recipient (1-to-1) or it's a broadcast
if (recipientId) {
  // 1-to-1 message: send to specific recipient
  getRecipientPushSubscription(recipientId).then(async subscription => {
    if (subscription) {
      const result = await sendPushNotification(subscription, {
        title: 'New Message',
        body: content.length > 100 ? content.substring(0, 97) + '...' : content,
        tag: `message-${roomId}-${recipientId}`,
        url: `/room/${roomId}`,
        roomId,
      })

      // If subscription expired, we could clean it up here
      // (optional enhancement - not required for gap closure)
      if (result.expired) {
        console.log('Push subscription expired for recipient:', recipientId)
      }
    }
  }).catch(err => {
    console.error('Failed to send push notification:', err)
  })
} else {
  // Broadcast message: send to all subscribed participants except sender
  getRoomPushSubscriptions(roomId, senderId).then(async subscriptions => {
    const pushPromises = subscriptions.map(subscription =>
      sendPushNotification(subscription, {
        title: 'Broadcast',
        body: content.length > 100 ? content.substring(0, 97) + '...' : content,
        tag: `broadcast-${roomId}`,
        url: `/room/${roomId}`,
        roomId,
      }).catch(err => {
        console.error('Failed to send broadcast push:', err)
      })
    )
    await Promise.allSettled(pushPromises)
  }).catch(err => {
    console.error('Failed to get room push subscriptions:', err)
  })
}
```

Key design decisions:
- Fire-and-forget pattern: Push is async, don't block message return
- Promise.allSettled for broadcasts: One failure doesn't stop others
- Error handling: Log failures but don't throw
- Content truncation: Push body limited to 100 chars for readability
- Tag for deduplication: Same tag replaces previous notification
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Code review: Verify sendPushNotification is called in sendMessage function
  </verify>
  <done>
sendMessage function calls getRecipientPushSubscription + sendPushNotification for 1-to-1 messages, and getRoomPushSubscriptions + sendPushNotification for broadcasts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify integration and test build</name>
  <files>src/lib/message-helpers.ts, src/lib/push-subscription.ts</files>
  <action>
1. Run full build to verify no errors:
   `npm run build`

2. Verify the key wiring with grep:
   - `grep -n "sendPushNotification" src/lib/message-helpers.ts` should show import and usage
   - `grep -n "getRecipientPushSubscription" src/lib/message-helpers.ts` should show import and usage

3. Review push-subscription.ts exports:
   - Ensure getRecipientPushSubscription and getRoomPushSubscriptions are exported
  </action>
  <verify>
`npm run build` completes successfully without errors. Grep commands show sendPushNotification and getRecipientPushSubscription are used in message-helpers.ts.
  </verify>
  <done>
Build passes, sendPushNotification is wired into the message sending flow. PUSH-02 requirement is now satisfied.
  </done>
</task>

</tasks>

<verification>
## Code Verification

1. **Import exists:** `grep "sendPushNotification" src/lib/message-helpers.ts` shows import
2. **Function called:** `grep -A5 "sendPushNotification" src/lib/message-helpers.ts` shows call in sendMessage
3. **Build passes:** `npm run build` completes without errors

## Functional Verification (requires running app)

1. Open app in two browsers (Storyteller + Player)
2. Player enables push notifications
3. Put Player's browser tab in background
4. Storyteller sends message to Player
5. Player should receive push notification

## Gap Closure Verification

The gap identified in VERIFICATION.md:
- **Before:** sendPushNotification exported but never called
- **After:** sendPushNotification called in sendMessage for both 1-to-1 and broadcast messages
</verification>

<success_criteria>
1. sendPushNotification is imported and called in src/lib/message-helpers.ts
2. getRecipientPushSubscription and getRoomPushSubscriptions exist in src/lib/push-subscription.ts
3. npm run build passes without errors
4. 1-to-1 messages trigger push to recipient (when subscribed)
5. Broadcast messages trigger push to all subscribed participants except sender
</success_criteria>

<output>
After completion, create `.planning/phases/06-polish-pwa/06-06-SUMMARY.md`
</output>
