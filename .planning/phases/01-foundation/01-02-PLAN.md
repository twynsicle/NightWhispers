---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - supabase/migrations/001_initial_schema.sql
  - src/lib/supabase.ts
  - src/App.tsx
  - .env
autonomous: true
user_setup:
  - service: supabase
    why: "Backend database and realtime infrastructure"
    env_vars:
      - name: VITE_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: VITE_SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> anon public key"
    dashboard_config:
      - task: "Create new Supabase project"
        location: "https://supabase.com/dashboard -> New Project"
      - task: "Enable Anonymous Sign-ins"
        location: "Supabase Dashboard -> Authentication -> Providers -> Anonymous"

must_haves:
  truths:
    - "Supabase project exists with database schema"
    - "RLS policies are enabled on all tables"
    - "Developer can connect to Supabase from the client and query tables"
    - "No anonymous access without valid session"
  artifacts:
    - path: "supabase/migrations/001_initial_schema.sql"
      provides: "Database schema for rooms, participants, messages"
      contains: "CREATE TABLE"
    - path: "src/lib/supabase.ts"
      provides: "Supabase client singleton"
      exports: ["supabase"]
  key_links:
    - from: "src/lib/supabase.ts"
      to: "src/lib/env.ts"
      via: "environment variable import"
      pattern: "import.*env"
    - from: "src/App.tsx"
      to: "src/lib/supabase.ts"
      via: "supabase client import"
      pattern: "import.*supabase"

---

<objective>
Create the Supabase database schema with RLS policies and verify client connectivity.

Purpose: Establish the backend data layer that all game functionality depends on - rooms, participants, and messages with proper security.

Output: Database schema deployed, RLS policies active, React client successfully queries Supabase.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database schema migration</name>
  <files>
    supabase/migrations/001_initial_schema.sql
  </files>
  <action>
Create directory supabase/migrations/ and the initial schema migration file.

The schema follows the architecture research with these tables:

**rooms table:**
```sql
CREATE TABLE rooms (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  code CHAR(4) NOT NULL UNIQUE,
  storyteller_id UUID NOT NULL,
  status TEXT NOT NULL DEFAULT 'lobby' CHECK (status IN ('lobby', 'active', 'ended')),
  phase TEXT NOT NULL DEFAULT 'Night 1',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  expires_at TIMESTAMPTZ NOT NULL DEFAULT (now() + INTERVAL '1 hour'),
  CONSTRAINT code_uppercase CHECK (code = UPPER(code))
);

CREATE INDEX idx_rooms_code ON rooms(code);
CREATE INDEX idx_rooms_expires_at ON rooms(expires_at);
```

**participants table:**
```sql
CREATE TABLE participants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  room_id UUID NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
  user_id UUID NOT NULL,
  display_name TEXT NOT NULL,
  avatar_id TEXT,
  role TEXT NOT NULL DEFAULT 'player' CHECK (role IN ('storyteller', 'player')),
  status TEXT NOT NULL DEFAULT 'alive' CHECK (status IN ('alive', 'dead')),
  custom_status TEXT,
  is_active BOOLEAN NOT NULL DEFAULT true,
  sort_order INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(room_id, user_id)
);

CREATE INDEX idx_participants_room_id ON participants(room_id);
CREATE INDEX idx_participants_user_id ON participants(user_id);
```

**messages table:**
```sql
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  room_id UUID NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES participants(id) ON DELETE CASCADE,
  recipient_id UUID REFERENCES participants(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  is_broadcast BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_messages_room_id ON messages(room_id);
CREATE INDEX idx_messages_sender_id ON messages(sender_id);
CREATE INDEX idx_messages_recipient_id ON messages(recipient_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);
```

**Notes:**
- recipient_id NULL = Storyteller broadcast (visible to all players)
- is_broadcast flag for explicit broadcast messages
- All timestamps in UTC (TIMESTAMPTZ)
- Cascading deletes ensure room deletion cleans up all data
  </action>
  <verify>
File supabase/migrations/001_initial_schema.sql exists with CREATE TABLE statements for rooms, participants, messages
SQL syntax is valid (no typos in constraints, proper foreign keys)
  </verify>
  <done>
Database schema migration file created with rooms, participants, messages tables
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RLS policies migration</name>
  <files>
    supabase/migrations/002_rls_policies.sql
  </files>
  <action>
Create RLS policies migration file. These policies enforce:
1. Only authenticated users can access any data
2. Users can only see/modify data in rooms they belong to
3. Storytellers have elevated permissions within their rooms

```sql
-- Enable RLS on all tables
ALTER TABLE rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- Helper function: Check if user is participant in room
CREATE OR REPLACE FUNCTION is_room_participant(room_uuid UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM participants
    WHERE room_id = room_uuid
    AND user_id = auth.uid()
    AND is_active = true
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function: Check if user is storyteller of room
CREATE OR REPLACE FUNCTION is_room_storyteller(room_uuid UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM participants
    WHERE room_id = room_uuid
    AND user_id = auth.uid()
    AND role = 'storyteller'
    AND is_active = true
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ROOMS POLICIES
-- Anyone authenticated can create a room (they become storyteller)
CREATE POLICY "users_can_create_rooms" ON rooms
  FOR INSERT TO authenticated
  WITH CHECK (true);

-- Users can view rooms they participate in
CREATE POLICY "participants_can_view_room" ON rooms
  FOR SELECT TO authenticated
  USING (is_room_participant(id));

-- Only storyteller can update their room
CREATE POLICY "storyteller_can_update_room" ON rooms
  FOR UPDATE TO authenticated
  USING (is_room_storyteller(id))
  WITH CHECK (is_room_storyteller(id));

-- PARTICIPANTS POLICIES
-- Participants can view other participants in their room
CREATE POLICY "participants_can_view_room_members" ON participants
  FOR SELECT TO authenticated
  USING (is_room_participant(room_id));

-- Users can join a room (insert themselves)
CREATE POLICY "users_can_join_room" ON participants
  FOR INSERT TO authenticated
  WITH CHECK (user_id = auth.uid());

-- Users can update their own participant record
CREATE POLICY "users_can_update_self" ON participants
  FOR UPDATE TO authenticated
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- Storyteller can update any participant in their room (for kicks, status changes)
CREATE POLICY "storyteller_can_update_participants" ON participants
  FOR UPDATE TO authenticated
  USING (is_room_storyteller(room_id))
  WITH CHECK (is_room_storyteller(room_id));

-- MESSAGES POLICIES
-- Participants can view messages where they are sender, recipient, or it's a broadcast
CREATE POLICY "participants_can_view_own_messages" ON messages
  FOR SELECT TO authenticated
  USING (
    is_room_participant(room_id) AND (
      sender_id IN (SELECT id FROM participants WHERE user_id = auth.uid()) OR
      recipient_id IN (SELECT id FROM participants WHERE user_id = auth.uid()) OR
      (is_broadcast = true)
    )
  );

-- Storyteller can view ALL messages in their room
CREATE POLICY "storyteller_can_view_all_messages" ON messages
  FOR SELECT TO authenticated
  USING (is_room_storyteller(room_id));

-- Participants can send messages (sender must be their participant record)
CREATE POLICY "participants_can_send_messages" ON messages
  FOR INSERT TO authenticated
  WITH CHECK (
    is_room_participant(room_id) AND
    sender_id IN (SELECT id FROM participants WHERE user_id = auth.uid() AND is_active = true)
  );

-- Grant execute on helper functions
GRANT EXECUTE ON FUNCTION is_room_participant TO authenticated;
GRANT EXECUTE ON FUNCTION is_room_storyteller TO authenticated;
```

**Security notes:**
- SECURITY DEFINER on helper functions allows them to query participants table
- Players can only see messages they sent, received, or broadcasts
- Storyteller sees all messages in their room
- No anonymous access possible (all policies require 'authenticated' role)
  </action>
  <verify>
File supabase/migrations/002_rls_policies.sql exists
Contains ALTER TABLE ... ENABLE ROW LEVEL SECURITY for all three tables
Contains CREATE POLICY statements for rooms, participants, messages
Helper functions created with SECURITY DEFINER
  </verify>
  <done>
RLS policies migration created - no anonymous access, room-scoped data isolation, storyteller elevation
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Supabase client and verify connection</name>
  <files>
    src/lib/supabase.ts
    src/App.tsx
    .env
  </files>
  <action>
**PREREQUISITE:** User must complete Supabase setup first (see user_setup in frontmatter). After user provides credentials, proceed.

Create .env file from .env.example with actual Supabase credentials:
```
VITE_SUPABASE_URL=<user-provided-url>
VITE_SUPABASE_ANON_KEY=<user-provided-key>
```

Create src/lib/supabase.ts:
```typescript
import { createClient } from '@supabase/supabase-js';
import { env } from './env';

// Single Supabase client instance
// IMPORTANT: Do not create multiple clients (causes connection issues)
export const supabase = createClient(env.supabase.url, env.supabase.anonKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
});

// Type exports for database (placeholder - will be generated later)
export type Database = {
  public: {
    Tables: {
      rooms: {
        Row: {
          id: string;
          code: string;
          storyteller_id: string;
          status: 'lobby' | 'active' | 'ended';
          phase: string;
          created_at: string;
          expires_at: string;
        };
      };
      participants: {
        Row: {
          id: string;
          room_id: string;
          user_id: string;
          display_name: string;
          avatar_id: string | null;
          role: 'storyteller' | 'player';
          status: 'alive' | 'dead';
          custom_status: string | null;
          is_active: boolean;
          sort_order: number;
          created_at: string;
          updated_at: string;
        };
      };
      messages: {
        Row: {
          id: string;
          room_id: string;
          sender_id: string;
          recipient_id: string | null;
          content: string;
          is_broadcast: boolean;
          created_at: string;
        };
      };
    };
  };
};
```

Update src/App.tsx to add a connection verification on mount:
```typescript
// Add useEffect to verify Supabase connection
useEffect(() => {
  async function checkConnection() {
    try {
      // Simple query to verify connection (will fail with RLS, but connection works)
      const { error } = await supabase.from('rooms').select('count').limit(0);

      if (error && !error.message.includes('permission denied')) {
        console.error('Supabase connection error:', error.message);
      } else {
        console.log('Supabase connected successfully');
      }
    } catch (err) {
      console.error('Supabase connection failed:', err);
    }
  }

  if (env.supabase.url && env.supabase.anonKey) {
    checkConnection();
  } else {
    console.warn('Supabase credentials not configured - see .env.example');
  }
}, []);
```

This verifies the client can reach Supabase. RLS will block actual data access until authenticated, which is correct behavior.
  </action>
  <verify>
Run `npm run dev` and check browser console:
- Should show "Supabase connected successfully" OR
- Should show permission denied error (means connection works, RLS is blocking as expected)
- Should NOT show network/connection errors

`npx tsc --noEmit` passes (TypeScript validates supabase module)
  </verify>
  <done>
Supabase client configured, connection verified from browser, RLS blocking unauthenticated access
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. supabase/migrations/ contains 001_initial_schema.sql and 002_rls_policies.sql
2. Migrations can be applied via Supabase Dashboard SQL Editor or Supabase CLI
3. `npm run dev` shows "Supabase connected successfully" in console
4. .env contains valid Supabase credentials (gitignored)
5. src/lib/supabase.ts exports typed client

**To apply migrations:**
Option A (Dashboard): Copy SQL from migration files into Supabase Dashboard -> SQL Editor -> Run
Option B (CLI): `npx supabase db push` (requires Supabase CLI setup)
</verification>

<success_criteria>
- Database schema ready (rooms, participants, messages tables defined)
- RLS policies enforce authentication and room-scoped access
- Supabase client connects from React app
- No anonymous/unauthenticated data access possible
- Foundation complete for Phase 2 (Session & Room Entry)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
