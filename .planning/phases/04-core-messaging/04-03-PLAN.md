---
phase: 04-core-messaging
plan: 03
type: execute
wave: 3
depends_on: [04-02]
files_modified:
  - src/hooks/useTypingIndicator.ts
  - src/hooks/useUnreadCount.ts
  - src/components/MessageInput.tsx
  - src/components/MessageList.tsx
  - src/components/StorytellerDashboard.tsx
  - src/components/PlayerChatView.tsx
  - supabase/migrations/003_message_tracking.sql
autonomous: true

must_haves:
  truths:
    - "Typing indicator appears when other party starts typing"
    - "Typing indicator disappears after 3 seconds of inactivity"
    - "Unread count displays on player cards for Storyteller"
    - "Unread count resets when conversation opened"
    - "last_read_at timestamp tracks read state per participant"
  artifacts:
    - path: "src/hooks/useTypingIndicator.ts"
      provides: "Presence-based typing state management"
      min_lines: 50
      exports: ["useTypingIndicator", "getTypingUsers"]
    - path: "src/hooks/useUnreadCount.ts"
      provides: "Unread message count tracking"
      min_lines: 40
      exports: ["useUnreadCount", "markConversationRead"]
    - path: "supabase/migrations/003_message_tracking.sql"
      provides: "last_read_at column for unread tracking"
      contains: "ALTER TABLE participants ADD COLUMN last_read_at"
  key_links:
    - from: "src/hooks/useTypingIndicator.ts"
      to: "channel.track()"
      via: "Presence state update"
      pattern: "channel\\.track\\(.*typing"
    - from: "src/hooks/useUnreadCount.ts"
      to: "supabase.from('messages').select"
      via: "Count query with last_read_at filter"
      pattern: "gt\\('created_at'.*last_read_at"
    - from: "src/components/MessageInput.tsx"
      to: "setIsTyping(true)"
      via: "onChange handler"
      pattern: "onChange.*setIsTyping"
---

<objective>
Add typing indicators and unread message tracking to complete messaging features.

Purpose: Deliver MSG-05 (unread counts) and MSG-07 (typing indicators) using Supabase Presence for ephemeral typing state and database timestamps for unread tracking.

Output: Real-time typing indicators, unread badges on player cards, and automatic read state management.
</objective>

<execution_context>
@C:\workspace\storychat\.claude\get-shit-done\workflows\execute-plan.md
@C:\workspace\storychat\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\workspace\storychat\.planning\PROJECT.md
@C:\workspace\storychat\.planning\ROADMAP.md
@C:\workspace\storychat\.planning\STATE.md
@C:\workspace\storychat\.planning\phases\04-core-messaging\04-RESEARCH.md

# Message infrastructure from Plan 04-01
@C:\workspace\storychat\.planning\phases\04-core-messaging\04-01-SUMMARY.md

# UI components from Plan 04-02
@C:\workspace\storychat\.planning\phases\04-core-messaging\04-02-SUMMARY.md

# Existing hooks pattern
@C:\workspace\storychat\src\hooks\useParticipants.ts
@C:\workspace\storychat\src\hooks\useMessages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add database migration for unread tracking</name>
  <files>
    supabase/migrations/003_message_tracking.sql
  </files>
  <action>
**Create supabase/migrations/003_message_tracking.sql:**

Add last_read_at column to participants table for unread message tracking.

Migration content:
```sql
-- Add last_read_at timestamp for unread message tracking
-- Pattern from RESEARCH.md Pattern 3: Unread Message Tracking

ALTER TABLE participants
ADD COLUMN last_read_at TIMESTAMPTZ;

-- Index for efficient unread count queries
-- Query pattern: messages.created_at > participants.last_read_at
CREATE INDEX idx_participants_last_read_at ON participants(last_read_at);

COMMENT ON COLUMN participants.last_read_at IS 'Last time participant viewed messages. Used to calculate unread count.';
```

Apply migration:
```bash
cd supabase
npx supabase db push
```

**Do NOT:**
- Use separate unread_count column (leads to race conditions per RESEARCH.md Pitfall 6)
- Add NOT NULL constraint (existing participants have no read timestamp)
- Forget index (unread queries scan messages table filtered by timestamp)

**Why:**
- last_read_at pattern is standard for unread tracking (Discord, Slack, Stream Chat)
- Timestamp comparison (created_at > last_read_at) is race-condition safe
- NULL last_read_at means "never read" (all messages are unread)
  </action>
  <verify>
- Migration file exists at supabase/migrations/003_message_tracking.sql
- Migration runs without errors: `npx supabase db push`
- participants table has last_read_at column (TIMESTAMPTZ, nullable)
- Index idx_participants_last_read_at exists
- Database connection still works (query participants table)
  </verify>
  <done>
- last_read_at column added to participants table
- Migration applied to database
- Index created for efficient unread count queries
  </done>
</task>

<task type="auto">
  <name>Task 2: Create typing indicator and unread count hooks</name>
  <files>
    src/hooks/useTypingIndicator.ts
    src/hooks/useUnreadCount.ts
  </files>
  <action>
**Create src/hooks/useTypingIndicator.ts:**

Follow RESEARCH.md Pattern 4 (Typing Indicator with Presence + Debounce).

```typescript
export function useTypingIndicator(
  channel: RealtimeChannel | null,
  participantId: string
): {
  setIsTyping: (typing: boolean) => void
  typingUsers: string[]
}
```

Implementation:
- Import useDebouncedValue from @mantine/hooks
- useState for isTyping (boolean) and typingUsers (string[])
- Debounce isTyping with 1000ms (1 second) using useDebouncedValue
- useEffect on debouncedTyping: call channel.track({ participantId, typing: debouncedTyping, timestamp: new Date().toISOString() })
- useEffect on isTyping: set timeout to clear after 3000ms (3 seconds), cleanup timeout
- Subscribe to Presence sync events: extract typing users from channel.presenceState()
- Filter out current participant and stale entries (older than 10 seconds)

```typescript
export function getTypingUsers(
  presenceState: Record<string, any[]>,
  currentParticipantId: string
): string[]
```

Implementation (RESEARCH.md lines 626-649):
- Iterate presenceState entries
- Take first presence (latest via CRDT)
- If typing === true and participantId !== current and timestamp < 10s old: add to array
- Return array of participant IDs

**Create src/hooks/useUnreadCount.ts:**

Follow RESEARCH.md Pattern 3 (Unread Message Tracking with last_read_at).

```typescript
export function useUnreadCount(
  roomId: string,
  participantId: string,
  conversationParticipantId: string | null
): number
```

Implementation (RESEARCH.md lines 652-698):
- useState for unreadCount (number)
- useEffect on [roomId, participantId, conversationParticipantId]:
  - Query participants table for current participant's last_read_at
  - Default to '1970-01-01' if NULL
  - Count messages where created_at > last_read_at AND (1-to-1 filter OR broadcast filter)
  - 1-to-1: sender_id = conversationParticipantId AND recipient_id = participantId
  - Broadcast: is_broadcast = true
  - Set unreadCount state
- Return unreadCount

```typescript
export async function markConversationRead(
  participantId: string
): Promise<void>
```

Implementation:
- Update participants table set last_read_at = NOW() where id = participantId
- Use database server timestamp (not client timestamp per RESEARCH.md Pitfall 6)

**Do NOT:**
- Call track() on every keystroke (use debounce per RESEARCH.md Pitfall 4)
- Use separate unread_count column (race conditions)
- Forget to filter stale typing indicators (presence cleanup takes 30s)
- Use client timestamp for last_read_at (clock skew issues)

**Why:**
- Debounce prevents Presence spam (1 update/sec max vs 10+ updates/sec without)
- last_read_at pattern handles concurrent updates safely
- Presence CRDT handles state merging automatically (no manual conflict resolution)
  </action>
  <verify>
- TypeScript compiles without errors
- useTypingIndicator.ts exports useTypingIndicator and getTypingUsers
- useUnreadCount.ts exports useUnreadCount and markConversationRead
- useTypingIndicator uses useDebouncedValue with 1000ms debounce
- useTypingIndicator calls channel.track() with typing state
- useUnreadCount queries messages with created_at > last_read_at filter
- markConversationRead updates participants.last_read_at with NOW()
  </verify>
  <done>
- useTypingIndicator hook manages Presence-based typing state
- useUnreadCount hook calculates unread messages from database
- markConversationRead function updates read timestamp
- Hooks ready for integration into UI components
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate typing indicators and unread counts into UI</name>
  <files>
    src/components/MessageInput.tsx
    src/components/MessageList.tsx
    src/components/StorytellerDashboard.tsx
    src/components/PlayerChatView.tsx
  </files>
  <action>
**Update src/components/MessageInput.tsx:**

Add typing indicator emission on input change.

Changes:
- Add prop: typingHandler?: { setIsTyping: (typing: boolean) => void }
- In Textarea onChange: call typingHandler?.setIsTyping(true)
- On form submit (send): call typingHandler?.setIsTyping(false)
- On component unmount: call typingHandler?.setIsTyping(false) in useEffect cleanup

**Update src/components/MessageList.tsx:**

Add typing indicator display below messages.

Changes:
- Add prop: typingUsers?: string[] (participant IDs currently typing)
- Add prop: participants?: Participant[] (to resolve IDs to names)
- Below message list, before scroll anchor: show typing indicator if typingUsers.length > 0
- Format: "{name} is typing..." using participants.find(p => p.id === typingUserId)?.display_name
- Use Mantine Text with italic style and size="sm"
- Gothic theme: color="dimmed"

**Update src/components/PlayerChatView.tsx:**

Integrate typing indicator hook.

Changes:
- Get channel from useMessages hook (add channel to return value if not already)
- Use useTypingIndicator(channel, participantId) hook
- Pass setIsTyping to MessageInput as typingHandler
- Pass typingUsers to MessageList
- Filter typingUsers to show only storyteller (typingUsers.filter(id => id === storytellerId))

**Update src/components/StorytellerDashboard.tsx:**

Add unread badges to player cards.

Changes:
- For each player card, use useUnreadCount(roomId, participantId, player.id) hook
- Display unread count as Badge on card (top-right corner or next to name)
- Only show badge if count > 0
- Use Mantine Badge with color="red" and size="sm"
- For Broadcast card: show unread count of all broadcast messages (conversationParticipantId = null)
- When opening conversation (selectedParticipant set): call markConversationRead(participantId) in useEffect
- When closing conversation (back button): refetch unread count (forces recalculation)

**Update src/components/ConversationView.tsx:**

Integrate typing indicator.

Changes:
- Accept typingHandler and typingUsers props (pass from parent)
- Pass typingHandler to MessageInput
- Pass typingUsers to MessageList
- Call markConversationRead(participantId) on mount (when conversation opens)

**Do NOT:**
- Call markConversationRead on every message (only on conversation open)
- Show typing indicator for current user (filter out in typingUsers)
- Forget to clear typing state on unmount (memory leak)
- Use client-side unread count (always query database for source of truth)

**Why:**
- Typing indicator improves UX (user knows other party is responding)
- Unread badges direct attention to conversations needing response
- Mark read on open (not on message) prevents constant writes
  </action>
  <verify>
- TypeScript compiles without errors
- MessageInput calls setIsTyping(true) on onChange
- MessageList displays typing indicator when typingUsers.length > 0
- PlayerChatView integrates useTypingIndicator hook
- StorytellerDashboard shows unread badges on player cards
- ConversationView calls markConversationRead on mount
- Typing indicator text shows participant name (not ID)
  </verify>
  <done>
- Typing indicator appears when other party types
- Typing indicator disappears after 3 seconds of inactivity
- Unread count displays as badge on player cards
- Unread count resets when Storyteller opens conversation
- All MSG requirements (01-07) delivered
  </done>
</task>

</tasks>

<verification>
1. Database migration applied: participants table has last_read_at column
2. Player types message, Storyteller sees "Player is typing..." within 1 second
3. Storyteller types message, Player sees "Storyteller is typing..." within 1 second
4. Typing indicator disappears after 3 seconds of no typing
5. Storyteller sees unread badge (count > 0) on player card when player sends message
6. Storyteller opens conversation, unread badge resets to 0
7. Broadcast unread count displays separately on Broadcast card
</verification>

<success_criteria>
- MSG-05 delivered: Unread message count displays on player cards
- MSG-07 delivered: Typing indicator shows when other party is typing
- Typing state uses Supabase Presence with 1s debounce (no spam)
- Unread tracking uses last_read_at timestamp pattern (race-condition safe)
- All Phase 4 requirements (MSG-01 through MSG-07) complete
- Messages persist, display in real-time, with typing indicators and unread tracking
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-messaging/04-03-SUMMARY.md`
</output>
