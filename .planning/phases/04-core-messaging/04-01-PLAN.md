---
phase: 04-core-messaging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/supabase.ts
  - src/hooks/useMessages.ts
  - src/lib/message-helpers.ts
autonomous: true

must_haves:
  truths:
    - "User sees messages within 1 second of sending"
    - "Messages persist and reload after browser refresh"
    - "Sent messages appear immediately in sender's view (optimistic UI)"
    - "Message history shows chronological order from database"
  artifacts:
    - path: "src/hooks/useMessages.ts"
      provides: "Broadcast subscription + message history loading"
      min_lines: 80
      exports: ["useMessages"]
    - path: "src/lib/message-helpers.ts"
      provides: "Message sending utilities"
      min_lines: 40
      exports: ["sendMessage", "sendBroadcastMessage"]
    - path: "src/lib/supabase.ts"
      provides: "Message type definition"
      contains: "messages: {"
  key_links:
    - from: "src/hooks/useMessages.ts"
      to: "supabase.channel()"
      via: "Broadcast subscription"
      pattern: "supabase\\.channel\\(.*\\)\\.on\\('broadcast'"
    - from: "src/lib/message-helpers.ts"
      to: "supabase.from('messages').insert"
      via: "Database persistence"
      pattern: "supabase\\.from\\('messages'\\)\\.insert"
    - from: "src/lib/message-helpers.ts"
      to: "channel.send()"
      via: "Broadcast delivery"
      pattern: "channel\\.send\\("
---

<objective>
Create message infrastructure with Broadcast for real-time delivery and Postgres for persistence.

Purpose: Establish the foundation for all messaging features - dual-write pattern (DB + Broadcast), message history loading with cursor pagination, and room-scoped channel subscription.

Output: Message types, useMessages hook, and send utilities ready for UI integration.
</objective>

<execution_context>
@C:\workspace\storychat\.claude\get-shit-done\workflows\execute-plan.md
@C:\workspace\storychat\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\workspace\storychat\.planning\PROJECT.md
@C:\workspace\storychat\.planning\ROADMAP.md
@C:\workspace\storychat\.planning\STATE.md
@C:\workspace\storychat\.planning\phases\04-core-messaging\04-RESEARCH.md

# Prior infrastructure
@C:\workspace\storychat\src\lib\supabase.ts
@C:\workspace\storychat\src\hooks\useParticipants.ts
@C:\workspace\storychat\supabase\migrations\001_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create message types and helper functions</name>
  <files>
    src/lib/supabase.ts
    src/lib/message-helpers.ts
  </files>
  <action>
**Update src/lib/supabase.ts:**
- Message type already exists in Database type definition (lines 52-62)
- Add convenience type export: `export type Message = Database['public']['Tables']['messages']['Row']`

**Create src/lib/message-helpers.ts:**

Implement dual-write pattern from RESEARCH.md Pattern 2:

```typescript
export async function sendMessage(
  roomId: string,
  senderId: string,
  recipientId: string | null,
  content: string,
  channel: RealtimeChannel | null
): Promise<Message>
```

Logic:
1. Validate inputs (content not empty, sender/room exist)
2. Insert to database with recipient_id (null for broadcast) and is_broadcast flag
3. Use .select().single() to get created message with ID
4. Broadcast to channel with event 'message' and payload = message object
5. If ack: true enabled, check ackResponse === 'ok'
6. Return message object

Implement broadcast helper from RESEARCH.md Pattern 7:

```typescript
export async function sendBroadcastMessage(
  roomId: string,
  senderId: string,
  content: string,
  channel: RealtimeChannel | null
): Promise<Message>
```

Logic: Call sendMessage with recipientId = null, is_broadcast = true.

**Do NOT:**
- Use Postgres Changes for messaging (RESEARCH.md: Broadcast is 22x faster)
- Use offset/limit pagination (use cursor-based with message.id)
- Forget to set is_broadcast flag when recipient_id is null
- Create new channels per message (pass channel as param)

**Why:**
- Dual write ensures persistence (MSG-06) + real-time delivery (MSG-03)
- Broadcast with ack: true confirms server receipt
- Helpers centralize logic for reuse in Player + Storyteller views
  </action>
  <verify>
# Verify TypeScript compilation
npm run build 2>&1 | grep -E "(error TS|Build failed|Successfully compiled)"

# Verify Message type exported
grep -n "export type Message" src/lib/supabase.ts

# Verify helper exports
grep -n "export async function sendMessage" src/lib/message-helpers.ts
grep -n "export async function sendBroadcastMessage" src/lib/message-helpers.ts

# Verify dual-write pattern (DB insert + broadcast)
grep -n "\.insert\(" src/lib/message-helpers.ts
grep -n "channel\.send\(" src/lib/message-helpers.ts

# Verify .select().single() for returning created message
grep -n "\.select\(\)\.single\(\)" src/lib/message-helpers.ts
  </verify>
  <done>
- message-helpers.ts exists with sendMessage and sendBroadcastMessage functions
- Dual-write pattern implemented (DB insert + Broadcast send)
- Functions return Promise&lt;Message&gt; with database-generated ID
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useMessages hook with Broadcast subscription</name>
  <files>
    src/hooks/useMessages.ts
  </files>
  <action>
**Create src/hooks/useMessages.ts:**

Follow RESEARCH.md Pattern 6 (Subscription Lifecycle) and Complete useMessages Hook example (lines 463-587).

Hook signature:
```typescript
export function useMessages(
  roomId: string,
  participantId: string,
  recipientId: string | null
): {
  messages: Message[]
  loading: boolean
  sendMessage: (content: string) => Promise<Message>
  channel: RealtimeChannel | null
}
```

Implementation flow:
1. useState for messages (Message[]), loading (boolean), channel (RealtimeChannel | null)
2. useEffect on [roomId, participantId, recipientId]:
   - Load initial history: 50 messages, cursor-based, filtered by conversation
   - If recipientId: 1-to-1 conversation (sender=participantId + recipient=recipientId OR sender=recipientId + recipient=participantId)
   - If recipientId is null: broadcast messages only (is_broadcast = true)
   - Order by created_at ASC (chronological)
   - Create channel: `room:${roomId}` with config `{ broadcast: { ack: true, self: false } }`
   - Subscribe to 'broadcast' event 'message'
   - On message payload: filter by conversation relevance, add to messages (prevent duplicates with .some(m => m.id === newMessage.id))
   - Return cleanup: supabase.removeChannel(channel)
3. sendMessage wrapper: calls message-helpers sendMessage with current channel, optimistically adds to UI

**Query patterns (RESEARCH.md Pattern 5):**

1-to-1 conversation filter:
```typescript
.or(
  `and(sender_id.eq.${participantId},recipient_id.eq.${recipientId}),` +
  `and(sender_id.eq.${recipientId},recipient_id.eq.${participantId})`
)
```

Broadcast filter:
```typescript
.eq('is_broadcast', true)
```

**Broadcast subscription:**
- Channel config: `{ broadcast: { ack: true, self: false } }`
- self: false prevents sender seeing their own message twice (optimistic UI handles that)
- Event: 'message', payload contains full Message object

**Do NOT:**
- Use Postgres Changes for messages (use Broadcast per RESEARCH.md)
- Sort by arrival order (sort by created_at from database)
- Forget cleanup (memory leak warning in RESEARCH.md Pitfall 2)
- Create channel on every render (useState/useRef for persistence)

**Why:**
- Broadcast guarantees 224K msgs/sec vs 10K for Postgres Changes
- self: false + optimistic UI prevents duplicate messages (RESEARCH.md Pitfall 3)
- Cursor-based pagination prevents duplicates when new messages arrive (RESEARCH.md Pitfall 7)
  </action>
  <verify>
# Verify TypeScript compilation
npm run build 2>&1 | grep -E "(error TS|Build failed|Successfully compiled)"

# Verify hook export
grep -n "export function useMessages" src/hooks/useMessages.ts

# Verify initial message loading (database query)
grep -n "\.from('messages')" src/hooks/useMessages.ts
grep -n "\.order('created_at'" src/hooks/useMessages.ts

# Verify Broadcast subscription
grep -n "\.channel\(" src/hooks/useMessages.ts
grep -n "\.on\('broadcast'" src/hooks/useMessages.ts

# Verify channel config (ack: true, self: false)
grep -n "broadcast:.*ack.*true" src/hooks/useMessages.ts
grep -n "self.*false" src/hooks/useMessages.ts

# Verify cleanup
grep -n "removeChannel" src/hooks/useMessages.ts

# Verify conversation filters
grep -n "\.or\(" src/hooks/useMessages.ts
grep -n "is_broadcast" src/hooks/useMessages.ts
  </verify>
  <done>
- useMessages hook subscribes to Broadcast channel for real-time messages
- Initial message history loaded on mount (50 messages, cursor-based)
- Messages filtered by conversation (1-to-1 or broadcast)
- sendMessage function available for sending messages
- Cleanup prevents memory leaks
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npm run build` succeeds
2. Message types exported from supabase.ts
3. message-helpers.ts exports sendMessage and sendBroadcastMessage
4. useMessages.ts exports useMessages hook with Broadcast subscription
5. Database queries use cursor-based pagination (not offset/limit)
6. Broadcast channel config includes ack: true, self: false
7. Channel cleanup present in useEffect return
</verification>

<success_criteria>
- Message infrastructure ready for UI integration (hooks + helpers exported)
- Dual-write pattern implemented (database persistence + Broadcast delivery)
- useMessages hook loads message history and subscribes to real-time updates
- sendMessage functions write to DB and broadcast to channel with ack confirmation
- No Postgres Changes used for messaging (Broadcast only per RESEARCH.md)
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-messaging/04-01-SUMMARY.md`
</output>
