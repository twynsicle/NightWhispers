---
phase: 04-core-messaging
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - src/pages/RoomPage.tsx
  - src/components/MessageList.tsx
  - src/components/MessageInput.tsx
  - src/components/PlayerChatView.tsx
  - src/components/StorytellerDashboard.tsx
  - src/components/ConversationView.tsx
autonomous: true

must_haves:
  truths:
    - "Player sees only their private chat with Storyteller"
    - "Storyteller sees all players as cards with unread badges"
    - "Tapping player card opens conversation view"
    - "Both parties can send messages and see real-time delivery"
    - "Message list scrolls to bottom on new message"
  artifacts:
    - path: "src/components/PlayerChatView.tsx"
      provides: "Full-screen chat for players"
      min_lines: 60
      exports: ["PlayerChatView"]
    - path: "src/components/StorytellerDashboard.tsx"
      provides: "Player cards with unread badges"
      min_lines: 80
      exports: ["StorytellerDashboard"]
    - path: "src/components/ConversationView.tsx"
      provides: "Full chat view with message list + input"
      min_lines: 60
      exports: ["ConversationView"]
    - path: "src/components/MessageList.tsx"
      provides: "Scrollable message history"
      min_lines: 40
      exports: ["MessageList"]
    - path: "src/components/MessageInput.tsx"
      provides: "Text input with send button"
      min_lines: 30
      exports: ["MessageInput"]
  key_links:
    - from: "src/components/PlayerChatView.tsx"
      to: "useMessages hook"
      via: "Load player-storyteller conversation"
      pattern: "useMessages\\(.*recipientId.*\\)"
    - from: "src/components/StorytellerDashboard.tsx"
      to: "src/components/ConversationView.tsx"
      via: "Tap card to open conversation"
      pattern: "setSelectedParticipant"
    - from: "src/components/MessageInput.tsx"
      to: "sendMessage function"
      via: "Form submit handler"
      pattern: "onSubmit.*sendMessage"
---

<objective>
Build Player and Storyteller messaging views with real-time message delivery.

Purpose: Deliver MSG-01, MSG-02, MSG-03, MSG-04 requirements - players can message Storyteller, Storyteller can message individual players or broadcast to all, messages appear in real-time.

Output: Full chat interface for players (single conversation) and Storyteller (player cards + conversation view).
</objective>

<execution_context>
@C:\workspace\storychat\.claude\get-shit-done\workflows\execute-plan.md
@C:\workspace\storychat\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\workspace\storychat\.planning\PROJECT.md
@C:\workspace\storychat\.planning\ROADMAP.md
@C:\workspace\storychat\.planning\STATE.md
@C:\workspace\storychat\.planning\phases\04-core-messaging\04-RESEARCH.md

# Message infrastructure from Plan 04-01
@C:\workspace\storychat\.planning\phases\04-core-messaging\04-01-SUMMARY.md

# Prior UI patterns
@C:\workspace\storychat\src\components\ParticipantList.tsx
@C:\workspace\storychat\src\pages\RoomPage.tsx
@C:\workspace\storychat\src\hooks\useParticipants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared message UI components</name>
  <files>
    src/components/MessageList.tsx
    src/components/MessageInput.tsx
  </files>
  <action>
**Create src/components/MessageList.tsx:**

Scrollable message list with auto-scroll to bottom on new messages.

Props:
```typescript
interface MessageListProps {
  messages: Message[]
  currentParticipantId: string
  loading?: boolean
}
```

Implementation:
- Use Mantine ScrollArea with viewportRef for scroll control
- Map messages to display bubbles: sender name, content, timestamp
- Differentiate sent vs received (align right vs left, different colors)
- Use currentParticipantId to determine if message.sender_id matches (sent) or not (received)
- Auto-scroll to bottom on mount and when messages.length changes (useEffect with scrollIntoView)
- Show loading skeleton while loading (Skeleton count={3})
- Format timestamps with relative time ("2 min ago") using simple Date logic
- Gothic theme: sent messages crimson background, received messages dark.6 background

**Create src/components/MessageInput.tsx:**

Text input with send button, controlled form state.

Props:
```typescript
interface MessageInputProps {
  onSendMessage: (content: string) => Promise<void>
  disabled?: boolean
}
```

Implementation:
- Use Mantine Textarea (not TextInput - supports multiline)
- Form with onSubmit handler (prevents default, calls onSendMessage, clears input)
- Send button (ActionIcon or Button with IconSend from tabler-icons)
- Disable input and button while sending (local loading state)
- Clear textarea after successful send
- Show notification on send error (use Mantine notifications)
- Placeholder: "Type a message..."
- Enter to send (Shift+Enter for newline) - use onKeyDown handler

**Do NOT:**
- Load messages in these components (done by parent with useMessages)
- Create new Broadcast channels (use hook's sendMessage function)
- Use fixed heights (ScrollArea handles viewport)
- Forget auto-scroll (UX issue if user must manually scroll on every message)

**Why:**
- Shared components reduce duplication (Player and Storyteller use same UI)
- Auto-scroll UX matches chat app conventions (Discord, Slack, iMessage)
- Textarea supports multiline messages (TextInput truncates)
  </action>
  <verify>
# Verify TypeScript compilation
npm run build 2>&1 | grep -E "(error TS|Build failed|Successfully compiled)"

# Verify component exports
grep -n "export.*MessageList" src/components/MessageList.tsx
grep -n "export.*MessageInput" src/components/MessageInput.tsx

# Verify MessageList uses ScrollArea
grep -n "ScrollArea" src/components/MessageList.tsx

# Verify auto-scroll implementation
grep -n "scrollIntoView\|scrollTo" src/components/MessageList.tsx

# Verify MessageInput uses Textarea (not TextInput)
grep -n "Textarea" src/components/MessageInput.tsx

# Verify form submit handler
grep -n "onSubmit" src/components/MessageInput.tsx
  </verify>
  <done>
- MessageList displays messages with sent/received styling
- MessageInput provides text input with send button
- Auto-scroll to bottom on new messages working
- Components ready for integration into Player and Storyteller views
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Player and Storyteller messaging views</name>
  <files>
    src/components/PlayerChatView.tsx
    src/components/StorytellerDashboard.tsx
    src/components/ConversationView.tsx
    src/pages/RoomPage.tsx
  </files>
  <action>
**Create src/components/PlayerChatView.tsx:**

Full-screen chat view for players (single conversation with Storyteller).

Props:
```typescript
interface PlayerChatViewProps {
  roomId: string
  participantId: string
  storytellerId: string // Recipient for all messages
  storytellerName: string
}
```

Implementation:
- Use useMessages hook with recipientId = storytellerId (1-to-1 conversation)
- Header: "Chat with {storytellerName}" (shows who player is talking to)
- Body: MessageList component with messages from hook
- Footer: MessageInput component with onSendMessage calling hook's sendMessage
- Full height layout (Stack with h="100vh")
- Gothic theme header with crimson accent

**Note on broadcast messages:** PlayerChatView receives broadcast messages automatically because the useMessages hook subscribes to the room channel with recipientId=storytellerId. When Storyteller sends a broadcast (recipientId=null, is_broadcast=true), it's delivered via the same channel subscription. The hook's message filtering logic will need to accept both:
- 1-to-1 messages where (sender=storyteller AND recipient=player) OR (sender=player AND recipient=storyteller)
- Broadcast messages where is_broadcast=true

This means the useMessages hook (from 04-01) filters incoming broadcast messages by checking is_broadcast flag in addition to 1-to-1 filters. PlayerChatView doesn't need separate broadcast subscription.

**Create src/components/ConversationView.tsx:**

Reusable conversation component (used by Storyteller for individual chats).

Props:
```typescript
interface ConversationViewProps {
  roomId: string
  participantId: string
  recipientId: string | null // null for broadcast
  recipientName: string
  onBack?: () => void
}
```

Implementation:
- Same as PlayerChatView but with back button in header (calls onBack)
- If recipientId is null: "Broadcast to All Players" header
- Use useMessages hook with recipientId (null for broadcast)
- MessageList + MessageInput same pattern
- Back button uses ActionIcon with IconArrowLeft

**Create src/components/StorytellerDashboard.tsx:**

Player cards with unread badges, tap to open conversation.

Props:
```typescript
interface StorytellerDashboardProps {
  roomId: string
  participantId: string
  participants: Participant[]
}
```

Implementation:
- useState for selectedParticipant (Participant | null)
- If selectedParticipant: render ConversationView with onBack clearing selection
- Else: render player cards grid (SimpleGrid cols={1} on mobile, {2} on md)
- Each card: participant avatar, name, role badge, unread count badge (placeholder, real count in Plan 04-03)
- Card onClick sets selectedParticipant
- Add "Broadcast to All" card at top (special card, recipientId = null)
- Cards use Mantine Card component with hover effect
- Unread badge uses Mantine Badge with count (0 for now)

**Update src/pages/RoomPage.tsx:**

Integrate Player and Storyteller views when roomStatus === 'active'.

Changes:
- When roomStatus === 'active':
  - If isStoryteller: render StorytellerDashboard with roomId, participantId, participants
  - If player: render PlayerChatView with roomId, participantId, storytellerId, storytellerName
- Find storyteller from participants array: `participants.find(p => p.role === 'storyteller')`
- Pass storyteller.id as storytellerId, storyteller.display_name as storytellerName
- Remove placeholder "Game started" text

**Do NOT:**
- Mix lobby and active views in same component (status-driven conditional rendering)
- Hardcode participant data (use participants from useParticipants hook)
- Create separate Broadcast channel for each conversation (useMessages handles that)
- Create separate broadcast subscription in PlayerChatView (useMessages hook already filters broadcast messages when recipientId is set to storytellerId)

**Why:**
- Player sees single conversation (PLAY-01: player only chats with Storyteller)
- Storyteller sees all players (DASH-01: Storyteller sees all players as cards)
- Conversation view reusable for individual + broadcast chats
- Status-driven rendering from Phase 3 pattern (lobby/active separation)
- useMessages hook handles both 1-to-1 and broadcast filtering in a single subscription
  </action>
  <verify>
# Verify TypeScript compilation
npm run build 2>&1 | grep -E "(error TS|Build failed|Successfully compiled)"

# Verify component exports
grep -n "export.*PlayerChatView" src/components/PlayerChatView.tsx
grep -n "export.*StorytellerDashboard" src/components/StorytellerDashboard.tsx
grep -n "export.*ConversationView" src/components/ConversationView.tsx

# Verify PlayerChatView uses useMessages hook
grep -n "useMessages" src/components/PlayerChatView.tsx

# Verify StorytellerDashboard state management
grep -n "useState.*selectedParticipant" src/components/StorytellerDashboard.tsx

# Verify ConversationView back button
grep -n "onBack\|IconArrowLeft" src/components/ConversationView.tsx

# Verify RoomPage integration
grep -n "PlayerChatView\|StorytellerDashboard" src/pages/RoomPage.tsx
grep -n "roomStatus.*active" src/pages/RoomPage.tsx
  </verify>
  <done>
- Player sees full-screen chat with Storyteller when game active
- Storyteller sees player cards, can tap to open conversation
- Both views use MessageList and MessageInput components
- Messages send and appear in real-time via Broadcast
- Broadcast to All card available in Storyteller dashboard
- PlayerChatView receives broadcast messages through existing 1-to-1 subscription
  </done>
</task>

</tasks>

<verification>
1. Start game from lobby (status transitions to active)
2. Player view shows chat interface with Storyteller
3. Storyteller view shows player cards
4. Tap player card, conversation view opens with back button
5. Send message from Player, appears in Storyteller conversation within 1 second
6. Send message from Storyteller, appears in Player view within 1 second
7. Refresh browser, messages persist (loaded from database)
8. Broadcast message from Storyteller appears in all player views
</verification>

<success_criteria>
- MSG-01 delivered: Storyteller can send message to individual player
- MSG-02 delivered: Player can send message to Storyteller
- MSG-03 delivered: Messages display in real-time without page refresh
- MSG-04 delivered: Storyteller can broadcast message to all players
- MSG-06 delivered: Messages persist across reconnection
- PLAY-01 delivered: Player sees private chat with Storyteller only
- DASH-01 delivered: Storyteller sees all players as cards on mobile
- DASH-03 delivered: Storyteller can open full chat view with player
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-messaging/04-02-SUMMARY.md`
</output>
